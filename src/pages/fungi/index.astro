---
/**
 * üçÑ FUNGI INDEX PAGE
 * ===================
 * 
 * Main page showing all fungi with AMORPH morphs
 * Loads real data from Convex
 */

import BaseLayout from '@/amorph/core/layouts/BaseLayout.astro';
import { fetchFungi } from '@/amorph/core/convex';

// Fetch fungi data from Convex
const fungi = await fetchFungi();

console.log(`üìä Loaded ${fungi?.length || 0} fungi from Convex`);

/**
 * Extract relevant fields from fungus data dynamically
 * Only returns fields that actually exist in the data
 */
function getRelevantFields(fungus: any): string[] {
  const fieldPriority = [
    // Safety & Identification (highest priority)
    'edibility',
    'toxicityLevel',
    
    // Taxonomy (important for identification)
    'taxonomy.family',
    'taxonomy.genus',
    'taxonomy.order',
    
    // Culinary & Nutritional
    'culinaryAndNutritional.flavorProfile',
    'culinaryAndNutritional.preparationMethods',
    
    // Cultivation & Processing
    'cultivationAndProcessing.cultivationDifficulty',
    'cultivationAndProcessing.cultivationMethods',
    
    // Medicinal & Health
    'medicinalAndHealth.medicinalProperties',
    'medicinalAndHealth.activeCompounds',
    
    // Ecology & Habitat
    'ecologyAndHabitat.seasonality.primarySeason',
    'ecologyAndHabitat.substrate',
    
    // Physical Characteristics
    'physicalCharacteristics.capColor',
    'physicalCharacteristics.sporePrintColor',
    
    // Chemical & Properties
    'primaryCompounds',
    'secondaryMetabolites',
    
    // Commercial & Market
    'commercialAndMarket.commercialValue',
    'commercialAndMarket.marketSegments',
    
    // Research & Innovation
    'researchAndInnovation.researchInterest',
    'activeResearchAreas'
  ];

  // Helper to get nested value
  const getNestedValue = (obj: any, path: string): any => {
    return path.split('.').reduce((current, key) => current?.[key], obj);
  };

  // Filter to only fields that exist and have values
  const existingFields = fieldPriority.filter(field => {
    const value = getNestedValue(fungus, field);
    // Include if value exists and is not empty
    return value !== null && 
           value !== undefined && 
           value !== '' && 
           !(Array.isArray(value) && value.length === 0);
  });

  // Return max 8-10 fields to prevent overcrowding
  return existingFields.slice(0, 10);
}
---

<BaseLayout 
  title="Pilze - Funginomi AMORPH"
  description="Morphologische Pilz-Datenbank mit perspektivischen Ansichten"
  enableGlow={false}
  enableSearch={true}
  enableAnimation={true}
>
  <!-- Page Header -->
  <header style="margin-bottom: 2rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem;">

      <p style="font-size: 0.74rem; color: rgba(255, 255, 255, 0.8);">
        {fungi?.length || 0} Fungi - Open Source
      </p>
    </div>
    
    <!-- View Toggle -->
    <div class="view-toggle">
      <button class="view-btn active" data-view="grid">
        üìä Grid View
      </button>
      <button class="view-btn" data-view="bubble">
        ü´ß Bubble View
      </button>
    </div>
  </header>

  <!-- Bubble Host -->
  <bubble-host id="bubble-view-host" style="display: none;"></bubble-host>

  <!-- Fungi Grid -->
  <div class="fungi-grid" id="grid-view-host">
    {fungi && fungi.length > 0 ? (
      fungi.map((fungus: any) => (
        <div class="fungus-card" data-slug={fungus.slug}>
          <div class="card-image">
            <image-morph 
              src={`/images/fungi/${fungus.slug}.jpg`}
              alt={fungus.commonName}
            ></image-morph>
            {fungus.taxonomy && (
              <div class="image-overlay">
                {fungus.taxonomy.family && (
                  <div class="taxonomy-badge">
                    <span class="taxonomy-label">Familie</span>
                    <span class="taxonomy-value">{fungus.taxonomy.family}</span>
                  </div>
                )}
                {fungus.taxonomy.genus && (
                  <div class="taxonomy-badge">
                    <span class="taxonomy-label">Gattung</span>
                    <span class="taxonomy-value">{fungus.taxonomy.genus}</span>
                  </div>
                )}
              </div>
            )}
          </div>
          

          <div class="card-data">
            <!-- Dynamically render only fields that exist -->
            {getRelevantFields(fungus).map((field) => (
              <data-morph
                fungus-data={JSON.stringify(fungus)}
                field={field}
              ></data-morph>
            ))}
          </div>

          <a href={`/fungi/${fungus.slug}`} class="card-link">
            view fully ‚Üí
          </a>
        </div>
      ))
    ) : (
      <div class="empty-state">
        <p style="font-size: 1.5rem; color: rgba(255, 255, 255, 0.7); text-align: center;">
          üçÑ Keine Pilze gefunden
        </p>
        <p style="color: rgba(255, 255, 255, 0.5); text-align: center; margin-top: 0.5rem;">
          Searching Database
        </p>
      </div>
    )}
  </div>
</BaseLayout>

<style>
  /* Wood Floor Background Card - Always visible */
  .fungus-card {
    background: url('/images/woodfloor/Moss_Woodsf_Laub.png');
    background-size: cover;
    background-position: center;
    border-radius: 20px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.12);
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex;
    flex-direction: column;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
    height: auto;
    position: relative;
  }
  
  /* Dark overlay for better readability */
  .fungus-card::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.64));
    pointer-events: none;
    z-index: 1;
    transition: background 0.4s ease;
  }
  
  .fungus-card > * {
    position: relative;
    z-index: 2;
  }

  .fungus-card:hover,
  .fungus-card.touch-hover {
    transform: translateY(-8px) scale(1.02);
    box-shadow: 0 16px 48px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.1) inset;
    border-color: rgba(255, 255, 255, 0.2);
  }
  
  .fungus-card:hover::before,
  .fungus-card.touch-hover::before {
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.9));
  }

  .card-image {
    width: 100%;
    height: 0;
    padding-bottom: 75%; /* 4:3 aspect ratio - more compact */
    overflow: hidden;
    background: rgba(0, 0, 0, 0.2);
    position: relative;
  }

  .card-image image-morph {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  /* Force contain fit for images in cards */
  .card-image image-morph::part(image),
  .card-image image-morph .image,
  .card-image image-morph img {
    object-fit: contain !important;
  }

  .image-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(to top, rgba(0, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0.7) 50%, transparent 100%);
    padding: 0.75rem; /* Reduced padding */
    display: flex;
    gap: 0.75rem; /* Reduced gap */
    align-items: flex-end;
    z-index: 10;
  }

  .taxonomy-badge {
    display: flex;
    flex-direction: column;
    gap: 0.0625rem; /* Minimal gap */
  }

  .taxonomy-label {
    font-size: 0.5625rem; /* Smaller label */
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: rgba(255, 255, 255, 0.6);
  }

  .taxonomy-value {
    font-size: 0.8125rem; /* Smaller value */
    font-weight: 600;
    color: white;
    font-style: italic;
  }

  .card-header {
    padding: 1.25rem; /* Reduced from 2rem */
    backdrop-filter: none;
    flex-shrink: 0;
  }

  .card-header name-morph {
    display: block;
  }

  .card-header name-morph:first-child {
    margin-bottom: 0.5rem; /* Reduced from 0.75rem */
    font-size: 1.25rem; /* Slightly smaller */
    line-height: 1.3;
  }

  .quick-info {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.625rem 1rem; /* Reduced gaps */
    margin-top: 0.75rem; /* Reduced from 1rem */
    padding-top: 0.75rem; /* Reduced from 1rem */
  }

  .info-item {
    display: flex;
    flex-direction: column;
    gap: 0.1875rem; /* Reduced from 0.25rem */
    font-size: 0.8125rem;
  }

  .info-label {
    color: rgba(255, 255, 255, 0.5);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    font-size: 0.625rem; /* Slightly smaller */
  }

  .info-value {
    color: rgba(255, 255, 255, 0.95);
    font-weight: 600;
    font-size: 0.8125rem; /* Slightly smaller */
  }

  .card-data {
    padding: 1.25rem; /* Reduced from 1.75rem */
    display: flex;
    flex-direction: column;
    gap: 0.625rem; /* Reduced from 0.875rem */
    overflow-y: auto;
    overflow-x: hidden;
    max-height: 400px;
    scrollbar-width: none;
    -ms-overflow-style: none;
  }

  /* Hide scrollbar for Chrome/Safari/Opera */
  .card-data::-webkit-scrollbar {
    display: none;
  }

  .card-data data-morph {
    margin-bottom: 0;
    order: 999; /* Default: hidden at bottom until perspective activates */
  }

  .card-link {
    display: block;
    padding: 0.875rem 1.25rem; /* Reduced padding */
    text-align: center;
    background: rgba(0, 0, 0, 0.2);
    backdrop-filter: blur(8px);
    color: rgba(255, 255, 255, 0.9);
    text-decoration: none;
    font-weight: 600;
    font-size: 0.8125rem; /* Slightly smaller */
    text-transform: uppercase;
    letter-spacing: 0.05em;
    transition: all 0.3s ease;
    margin-top: auto;
    flex-shrink: 0;
  }

  .card-link:hover {
    background: rgba(0, 0, 0, 0.7);
    color: #22c55e;
    box-shadow: 0 -2px 12px rgba(34, 197, 94, 0.3) inset, 0 0 20px rgba(34, 197, 94, 0.1);
  }

  /* View Toggle - Black Glassmorphism */
  .view-toggle {
    display: flex;
    gap: 0.5rem;
    background: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(16px);
    padding: 0.375rem;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.02) inset;
  }

  .view-btn {
    padding: 0.75rem 1.5rem;
    background: transparent;
    border: none;
    border-radius: 8px;
    color: rgba(255, 255, 255, 0.6);
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .view-btn:hover {
    background: rgba(0, 0, 0, 0.6);
    color: rgba(255, 255, 255, 0.9);
  }

  .view-btn.active {
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(8px);
    color: white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1) inset;
  }

  /* Bubble Host */
  #bubble-view-host {
    margin-bottom: 2rem;
  }

  /* Fungi Grid */
  .fungi-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
    gap: 2.5rem;
    margin-bottom: 4rem;
    padding: 1rem 0;
    align-items: start; /* Align cards to top for better visual balance */
  }
  
  /* Morphs */
  .morphs {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }
  
  /* Tags */
  .tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin: 0.5rem 0;
  }
  
  /* Detail Link */
  .detail-link {
    display: inline-block;
    margin-top: 1rem;
    padding: 0.5rem 1rem;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    text-decoration: none;
    border-radius: 8px;
    font-weight: 500;
    transition: all 0.2s ease;
  }
  
  .detail-link:hover {
    transform: translateX(4px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
  }
  
  /* Empty State */
  .empty-state {
    grid-column: 1 / -1;
    padding: 4rem 2rem;
    text-align: center;
  }
  
  /* Responsive */
  @media (max-width: 768px) {
    .fungi-grid {
      grid-template-columns: 1fr;
      gap: 1.5rem;
    }
    
    .fungus-card {
      padding: 1rem;
    }

    header {
      flex-direction: column;
      align-items: flex-start !important;
    }
  }
  
  /* Dark Mode */
  @media (prefers-color-scheme: dark) {
    .fungus-card {
      /* Keep wood floor background visible in dark mode */
      color: rgba(255, 255, 255, 0.9);
    }
  }
</style>

<script define:vars={{ fungi }}>
  // Wait for AMORPH and hosts to load
  async function initViewToggle() {
    const amorph = window.amorph;
    if (!amorph) {
      console.log('‚è≥ Waiting for AMORPH...');
      setTimeout(initViewToggle, 100);
      return;
    }

    // Get host elements
    const bubbleHost = document.getElementById('bubble-view-host');
    const gridHost = document.getElementById('grid-view-host');
    
    if (!bubbleHost || !gridHost) {
      console.warn('‚ö†Ô∏è Host elements not found, retrying...');
      setTimeout(initViewToggle, 100);
      return;
    }

    // Wait for bubbleHost to be fully upgraded (web component ready)
    if (!bubbleHost.setData) {
      console.log('‚è≥ Waiting for BubbleHost to upgrade...');
      setTimeout(initViewToggle, 100);
      return;
    }

    // DATENGETRIEBEN: √úbergebe Fungi-Daten an BubbleHost
    console.log('üìä Fungi data:', fungi);
    bubbleHost.setData(fungi);
    console.log(`‚úÖ Passed ${fungi.length} fungi to BubbleHost`);

    // Enable connections by default for similarity visualization
    setTimeout(() => {
      const bubbleView = bubbleHost.shadowRoot?.querySelector('bubble-view');
      if (bubbleView) {
        bubbleView.showConnections = true;
        console.log('‚úÖ Enabled similarity-based connections in BubbleView');
      }
    }, 1000);

    // REMOVED: AstroDataSearchReactor - Replaced by SearchFilterController (see line 787-792)
    // SearchFilterController provides better performance and cleaner implementation

    // MorphHeader will initialize with 4 default perspectives automatically
    console.log('‚úÖ Perspectives will be initialized by MorphHeader');

    // FIFO Perspective Ordering System
    const perspectiveOrder = [];
    const perspectiveFieldMap = {
      'safetyAndIdentification': ['edibility', 'toxicityLevel'],
      'ecologyAndHabitat': ['ecologyAndHabitat.seasonality.primarySeason', 'ecologyAndHabitat.substrate'],
      'physicalCharacteristics': ['physicalCharacteristics.capColor', 'physicalCharacteristics.sporePrintColor'],
      'culinaryAndNutritional': ['culinaryAndNutritional.flavorProfile', 'culinaryAndNutritional.preparationMethods'],
      'medicinalAndHealth': ['medicinalAndHealth.medicinalProperties', 'medicinalAndHealth.activeCompounds'],
      'cultivationAndProcessing': ['cultivationAndProcessing.cultivationDifficulty', 'cultivationAndProcessing.cultivationMethods'],
      'culturalAndHistorical': ['culturalAndHistorical.historicalSignificance', 'culturalAndHistorical.firstDocumented'],
      'commercialAndMarket': ['commercialAndMarket.commercialValue', 'commercialAndMarket.marketSegments', 'commercialAndMarket.commercialProducts'],
      'environmentalAndConservation': ['environmentalAndConservation.ecologicalRole', 'environmentalAndConservation.ecosystemServices'],
      'researchAndInnovation': ['researchAndInnovation.researchInterest', 'activeResearchAreas', 'innovativeApplications'],
      'chemicalAndProperties': ['primaryCompounds', 'secondaryMetabolites'],
      'taxonomy': ['kingdom', 'phylum', 'class', 'order']
    };

    function updateDataMorphOrder() {
      const cards = document.querySelectorAll('.card-data');
      
      cards.forEach((cardData) => {
        const morphs = Array.from(cardData.querySelectorAll('data-morph'));
        
        morphs.forEach(morph => {
          const field = morph.getAttribute('field');
          let order = 999;
          
          for (let i = 0; i < perspectiveOrder.length; i++) {
            const perspectiveName = perspectiveOrder[i];
            const fields = perspectiveFieldMap[perspectiveName] || [];
            if (fields.includes(field)) {
              order = i * 10;
              break;
            }
          }
          
          morph.style.order = order;
        });
      });
    }

    // Listen to perspective changes from MorphHeader
    // MorphHeader dispatches: window.dispatchEvent(new CustomEvent('perspective-changed', { detail: { perspectives } }))
    console.log('‚úÖ Setting up perspective-changed listener');
    
    const perspectiveHandler = (event) => {
      const perspectives = event.detail?.perspectives || [];
      if (perspectives.length === 0) return;
      
      // SIMPLE FIFO: MorphHeader adds new perspectives to the END
      // So we REVERSE the array to get newest first
      perspectiveOrder.length = 0;
      perspectiveOrder.push(...perspectives.slice().reverse());
      
      updateDataMorphOrder();
    };
    
    // Listen ONLY to window event (MorphHeader dispatches to both window and document)
    window.addEventListener('perspective-changed', perspectiveHandler);
    
    console.log('‚úÖ Perspective listeners registered');

    // View Toggle functionality with coordinated state
    const viewBtns = document.querySelectorAll('.view-btn');
    let currentView = 'grid'; // Track current view

    viewBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        const view = btn.dataset.view;
        if (view === currentView) return; // Already on this view
        
        currentView = view;
        
        // Update active state
        viewBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Toggle views and activate appropriate reactors
        if (view === 'grid') {
          // Show Grid, Hide Bubble
          bubbleHost.style.display = 'none';
          gridHost.style.display = 'grid'; // Must be 'grid' not 'block'
          
          // Force reflow to ensure cards are visible
          void gridHost.offsetHeight;
          
          // Grid View: SearchFilterController handles search (already initialized)
          // Perspectives and search state are already shared via events
          
          const searchQuery = amorph.state.searchQuery || 'none';
          const perspectiveCount = amorph.state?.activePerspectives?.length || 0;
          console.log(`[ViewToggle] üìä Grid View | Search: "${searchQuery}" | Perspectives: ${perspectiveCount} active`);
          
        } else {
          // Show Bubble, Hide Grid
          gridHost.style.display = 'none';
          bubbleHost.style.display = 'block';
          
          // Bubble View: Enable perspective weighting and connections
          const bubbleView = bubbleHost.shadowRoot?.querySelector('bubble-view');
          if (bubbleView) {
            // Ensure connections are visible for relationship view
            bubbleView.showConnections = true;
            
            // üé® Re-enable Canvas Reactors when switching to Bubble View
            if (!bubbleView.reactorsEnabled) {
              bubbleView.enableCanvasReactors();
            }
            
            // Trigger similarity recalculation with current perspectives
            bubbleView.updateSimilarityMatrix();
            
            const searchQuery = amorph.state.searchQuery || 'none';
            const perspectiveCount = amorph.state?.activePerspectives?.length || 0;
            console.log(`[ViewToggle] ü™∑ Bubble View | Search: "${searchQuery}" | Perspectives: ${perspectiveCount} active | Connections: enabled`);
          }
          
          // Enable BubbleView-specific reactors
          if (window.amorph) {
            window.amorph.enableReactor('bubbleDetail');
            window.amorph.enableReactor('bubbleSearch');
            console.log('[ViewToggle] ‚úÖ Bubble reactors enabled (BubbleDetail, BubbleSearch)');
            
            // Trigger perspective update on all bubble morphs
            const bubbles = bubbleHost.shadowRoot?.querySelectorAll('bubble-morph') || [];
            bubbles.forEach(bubble => {
              if (window.amorph.state?.activePerspectives) {
                bubble.activePerspectives = window.amorph.state.activePerspectives;
                bubble.requestUpdate();
              }
            });
            if (bubbles.length > 0) {
              console.log(`[ViewToggle] üîÑ Updated ${bubbles.length} bubbles with active perspectives`);
            }
            
            // If there's an active search with cached results, apply to Bubble View
            const searchQuery = window.amorph.state?.searchQuery;
            const cachedResults = window.amorph.state?.searchResults;
            if (searchQuery && searchQuery.trim() !== '' && cachedResults && cachedResults.length > 0) {
              console.log('üîç [ViewToggle] Applying cached search to Bubble View:', searchQuery, `(${cachedResults.length} results)`);
              window.dispatchEvent(new CustomEvent('convex-search:completed', {
                detail: {
                  query: searchQuery,
                  results: cachedResults
                }
              }));
            } else if (searchQuery && searchQuery.trim() !== '') {
              console.log('‚ö†Ô∏è [ViewToggle] Search query exists but no cached results - skipping bubble creation');
            }
          }
        }
        
        // Both views share:
        // ‚úì Search query (via amorph.state.searchQuery and search:input events)
        // ‚úì Perspectives (via MorphHeader perspective-changed events)
        // ‚úì User interactions persist across view switches
      });
    });

    console.log('‚úÖ View toggle initialized with', fungi.length, 'fungi');
    console.log('‚úÖ Shared state: Search + Perspectives coordinated across views');
  }

  // Start initialization
  console.log('üöÄ Starting view toggle initialization...');
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initViewToggle);
  } else {
    initViewToggle();
  }
</script>

<!-- Search Filter Controller (NEW) -->
<script type="module">
  import { SearchFilterController } from '/src/amorph/features/search-system/SearchFilterController.js';
  
  // Initialize search filter for Grid View
  const searchFilter = new SearchFilterController('.fungi-grid', '.fungus-card');
  
  console.log('üîç SearchFilterController initialized for Grid View');
</script>

<!-- Dynamic DataMorph Mode Switcher -->
<script type="module">
  /**
   * üîÑ DYNAMIC DATAMORPH MODE SWITCHER
   * ==================================
   * 
   * Switches data-morph display modes based on user interaction:
   * - Initial load: mode="simple" with relevant fields (10 fields max)
   * - After search: mode="deep" showing ALL matched data
   * - After perspective change: mode="deep" showing ALL perspective data
   * 
   * This gives users full context when searching/filtering while keeping
   * initial load clean and performant.
   */
  
  class DataMorphModeSwitcher {
    constructor() {
      this.isSearchActive = false;
      this.isPerspectiveActive = false;
      this.currentQuery = '';
      this.matchedFields = {};
      this.activePerspectives = [];
      
      this.init();
    }
    
    init() {
      // Wait for DOM
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => this.setup());
      } else {
        this.setup();
      }
    }
    
    setup() {
      console.log('[DataMorphModeSwitcher] üé¨ Initializing...');
      
      // Store original field values in dataset for restoration
      const dataMorphs = document.querySelectorAll('.card-data data-morph[field]');
      dataMorphs.forEach(morph => {
        const field = morph.getAttribute('field');
        if (field) {
          morph.dataset.originalField = field;
        }
      });
      
      // Listen for search events
      window.addEventListener('convex-search:completed', (event) => {
        this.handleSearchCompleted(event.detail);
      });
      
      window.addEventListener('convex-search:reset', () => {
        this.handleSearchReset();
      });
      
      // Listen for perspective changes
      if (typeof amorph !== 'undefined') {
        amorph.on('perspectives:changed', (data) => {
          this.handlePerspectiveChange(data);
        });
      }
      
      console.log('[DataMorphModeSwitcher] ‚úÖ Ready - Listening for search and perspective events');
    }
    
    /**
     * Handle search completed - switch to deep mode
     */
    handleSearchCompleted(searchData) {
      const { query, results, matchedFields } = searchData;
      
      const fieldCount = matchedFields ? Object.keys(matchedFields).length : 0;
      console.log(`[DataMorphModeSwitcher] üîç Search "${query}" ‚Üí ${results?.length || 0} results (${fieldCount} with matched fields)`);
      
      // Update state
      this.isSearchActive = !!(query && query.trim().length >= 2);
      this.currentQuery = query || '';
      this.matchedFields = matchedFields || {};
      
      if (this.isSearchActive) {
        this.switchToDeepMode('search');
      } else {
        this.switchToSimpleMode();
      }
    }
    
    /**
     * Handle search reset - switch back to simple mode
     */
    handleSearchReset() {
      console.log('[DataMorphModeSwitcher] üîÑ Search reset');
      
      this.isSearchActive = false;
      this.currentQuery = '';
      this.matchedFields = {};
      
      // Only switch back to simple if no perspective is active
      if (!this.isPerspectiveActive) {
        this.switchToSimpleMode();
      }
    }
    
    /**
     * Handle perspective change - switch to deep mode
     */
    handlePerspectiveChange(data) {
      const { perspectives } = data || {};
      
      const perspectiveStr = perspectives?.join(', ') || 'none';
      console.log(`[DataMorphModeSwitcher] üé≠ Perspectives: ${perspectiveStr}`);
      
      this.isPerspectiveActive = !!(perspectives && perspectives.length > 0);
      this.activePerspectives = perspectives || [];
      
      if (this.isPerspectiveActive) {
        this.switchToDeepMode('perspective');
      } else if (!this.isSearchActive) {
        // Only switch back to simple if search is also inactive
        this.switchToSimpleMode();
      }
    }
    
    /**
     * Switch all visible cards to deep mode
     */
    switchToDeepMode(reason = 'unknown') {
      // Get all visible cards (not hidden by search filter)
      const cards = document.querySelectorAll('.fungus-card');
      let updatedCount = 0;
      
      cards.forEach(card => {
        // Skip hidden cards
        if (card.style.display === 'none') return;
        
        // Get all data-morphs in this card
        const dataMorphs = card.querySelectorAll('.card-data data-morph');
        
        dataMorphs.forEach((morph, index) => {
          if (index === 0) {
            // First morph: switch to deep mode (will render ALL perspectives)
            morph.setAttribute('mode', 'deep');
            morph.removeAttribute('field');
            morph.style.display = '';
            updatedCount++;
          } else {
            // Other morphs: hide them to prevent duplication
            morph.style.display = 'none';
          }
        });
      });
      
      console.log(`[DataMorphModeSwitcher] ‚úÖ Updated ${updatedCount} cards to deep mode (hidden duplicates)`);
    }
    
    /**
     * Switch all cards back to simple mode with relevant fields
     */
    switchToSimpleMode() {
      console.log('[DataMorphModeSwitcher] üìÑ Switching to SIMPLE mode (relevant fields)');
      
      // Get all cards
      const cards = document.querySelectorAll('.fungus-card');
      let updatedCount = 0;
      
      cards.forEach(card => {
        // Get all data-morphs in this card
        const dataMorphs = card.querySelectorAll('.card-data data-morph');
        
        dataMorphs.forEach((morph, index) => {
          // Show all morphs again (they were hidden in deep mode)
          morph.style.display = '';
          
          // Remove deep mode
          if (morph.hasAttribute('mode')) {
            morph.removeAttribute('mode');
          }
          
          // Restore field attribute from original field (stored in dataset)
          const originalField = morph.dataset.originalField;
          if (originalField) {
            morph.setAttribute('field', originalField);
          }
          
          updatedCount++;
        });
      });
      
      console.log(`[DataMorphModeSwitcher] ‚úÖ Updated ${updatedCount} data-morphs to simple mode`);
    }
  }
  
  // Initialize
  new DataMorphModeSwitcher();
</script>

<!-- Touch Hover Effects -->
<script type="module">
  // Touch-friendly hover effects for mobile scrolling
  function initTouchHover() {
    const cards = document.querySelectorAll('.fungus-card');
    let lastTouchedCard = null;
    
    cards.forEach(card => {
      // Touch start - add hover class
      card.addEventListener('touchstart', (e) => {
        // Remove hover from previously touched card
        if (lastTouchedCard && lastTouchedCard !== card) {
          lastTouchedCard.classList.remove('touch-hover');
        }
        
        // Add hover to current card
        card.classList.add('touch-hover');
        lastTouchedCard = card;
      }, { passive: true });
      
      // Touch end - keep hover until next card is touched
      card.addEventListener('touchend', () => {
        // Don't remove hover - it stays until another card is touched
      }, { passive: true });
    });
  }
  
  // Initialize after DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTouchHover);
  } else {
    initTouchHover();
  }
  
  console.log('üëÜ Touch-friendly hover initialized');
</script>
