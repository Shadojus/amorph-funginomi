---
/**
 * üçÑ ENTITY INDEX PAGE
 * ===================
 * 
 * Main page showing all entities with AMORPH morphs
 * Loads real data from Convex
 * Uses MorphMapper for intelligent morph type selection
 */

import BaseLayout from '@/amorph/core/layouts/BaseLayout.astro';
import { fetchEntities } from '@/amorph/core/convex';
// TypeScript module with field-to-perspective mappings
import { perspectiveSchemaFields, getFieldsForPerspective } from '@/amorph/core/perspectiveFieldMappings.ts';

// Build perspectiveDisplayFields for client-side use (simpler structure)
const perspectiveDisplayFields: Record<string, string[]> = {};
for (const [perspectiveId, data] of Object.entries(perspectiveSchemaFields)) {
  perspectiveDisplayFields[perspectiveId] = (data as any).displayFields || [];
}

// Fetch entity data from Convex
const entities = await fetchEntities();

console.log(`üìä Loaded ${entities?.length || 0} entities from Convex`);

// Debug: Show first entity structure
if (entities?.[0]) {
  const firstEntity = entities[0];
  console.log(`üìã First entity "${firstEntity.slug}" keys:`, Object.keys(firstEntity));
  if (firstEntity.taxonomy) {
    console.log(`   taxonomy type:`, typeof firstEntity.taxonomy);
    console.log(`   taxonomy keys:`, Object.keys(firstEntity.taxonomy));
    if (firstEntity.taxonomy.value) {
      console.log(`   taxonomy.value keys:`, Object.keys(firstEntity.taxonomy.value));
    }
  }
}

/**
 * MorphMapper - Server-side version
 * Determines correct morph type for each field - DATA DRIVEN!
 * Synchronized with client-side MorphMapper.js logic
 */
class ServerMorphMapper {
  constructor() {
    // NO hardcoded mappings - everything is data-driven!
  }

  getMorphType(fieldName: string, value: any): string {
    return this.getMorphByValueAnalysis(value, fieldName);
  }

  getMorphByValueAnalysis(value: any, fieldName: string = ''): string {
    if (value === null || value === undefined) {
      return 'text-morph';
    }

    const type = typeof value;

    // Boolean values ‚Üí BooleanMorph
    if (type === 'boolean') {
      return 'boolean-morph';
    }

    // Number values ‚Üí NumberMorph
    if (type === 'number') {
      return 'number-morph';
    }

    // String values - analyze content structure
    if (type === 'string') {
      const trimmed = value.trim();
      
      if (trimmed.length === 0) return 'text-morph';
      
      // Image URL detection
      if (this.isImageUrl(trimmed)) return 'image-morph';
      
      // Date/Time detection
      if (this.isDateString(trimmed)) return 'timeline-morph';
      
      // Short strings
      if (trimmed.length < 30 && !trimmed.includes('\n')) {
        if (trimmed.length < 15) return 'tag-morph';
        return 'name-morph';
      }
      
      return 'text-morph';
    }

    // Array values
    if (Array.isArray(value)) {
      if (value.length === 0) return 'list-morph';

      const firstItem = value[0];
      const itemType = typeof firstItem;
      
      // Array of strings
      if (itemType === 'string') {
        const avgLength = value.reduce((sum: number, item: any) => sum + (item?.length || 0), 0) / value.length;
        if (avgLength < 20) return 'tag-morph';
        return 'list-morph';
      }

      // Array of numbers
      if (itemType === 'number') {
        if (value.length < 5) return 'list-morph';
        if (value.length >= 5 && value.length <= 15) return 'sparkline-morph';
        return 'list-morph';
      }

      // Array of objects - NUR f√ºr strukturierte Chart-Daten
      if (itemType === 'object' && firstItem !== null) {
        const keys = Object.keys(firstItem);
        
        // MAP CHECK FIRST (geographicDistribution): [{location: {latitude, longitude}, name}]
        if (keys.includes('location') && firstItem.location && 
            typeof firstItem.location === 'object' &&
            (firstItem.location.latitude !== undefined || firstItem.location.lat !== undefined)) {
          return 'map-morph';
        }
        
        // TIMELINE CHECK (cultivationTimeline): [{dayOffset, stage, label, ...}]
        if ((keys.includes('dayOffset') || keys.includes('date') || keys.includes('timestamp')) &&
            (keys.includes('stage') || keys.includes('label') || keys.includes('event'))) {
          return 'timeline-morph';
        }
        
        const isSimpleObject = keys.length >= 2 && keys.length <= 3;
        
        const allSameStructure = value.every((item: any) => {
          if (typeof item !== 'object' || item === null) return false;
          const itemKeys = Object.keys(item);
          return itemKeys.length === keys.length && itemKeys.every(k => keys.includes(k));
        });
        
        if (isSimpleObject && allSameStructure) {
          // RADAR CHART (nutritionalProfile): [{axis, value}]
          if (value.length >= 3 && value.length <= 6 &&
              (keys.includes('axis') || keys.includes('dimension')) &&
              (keys.includes('value') || keys.includes('score') || keys.includes('rating'))) {
            return 'radar-chart-morph';
          }
          
          if (value.length >= 2 && value.length <= 6 &&
              (keys.includes('category') || keys.includes('type') || keys.includes('name')) &&
              (keys.includes('count') || keys.includes('percentage') || keys.includes('value'))) {
            return 'pie-chart-morph';
          }
          
          if (value.length >= 3 && value.length <= 8 &&
              (keys.includes('label') || keys.includes('month') || keys.includes('period')) &&
              (keys.includes('value') || keys.includes('amount'))) {
            return 'bar-chart-morph';
          }
        }
        
        return 'list-morph';
      }

      return 'list-morph';
    }

    // Object values
    if (type === 'object' && value !== null) {
      if (value instanceof Date) return 'timeline-morph';
      
      if (('lat' in value && 'lng' in value) || 
          ('latitude' in value && 'longitude' in value)) {
        return 'map-morph';
      }

      // Range object (min/max)
      if ('min' in value && 'max' in value) {
        return 'range-morph';
      }

      // Progress object
      if (('value' in value && 'max' in value) || 'percentage' in value) {
        return 'progress-morph';
      }

      // Small flat objects
      const primitiveFields = Object.entries(value).filter(([_, v]) => 
        typeof v !== 'object' || v === null
      );
      const hasNestedObjects = Object.values(value).some((v: any) => 
        typeof v === 'object' && v !== null && !Array.isArray(v)
      );
      const hasArrays = Object.values(value).some((v: any) => Array.isArray(v));
      
      if (primitiveFields.length > 0 && primitiveFields.length <= 5 && 
          !hasNestedObjects && !hasArrays && primitiveFields.length === Object.keys(value).length) {
        return 'key-value-morph';
      }

      return 'data-morph';
    }

    return 'text-morph';
  }

  isImageUrl(str: string): boolean {
    const imageExtensions = /\.(jpg|jpeg|png|gif|webp|svg|ico|bmp)$/i;
    const hasImageExtension = imageExtensions.test(str);
    const isUrlLike = str.startsWith('http') || str.startsWith('/') || str.startsWith('data:image');
    return isUrlLike && (hasImageExtension || str.includes('image') || str.startsWith('data:image'));
  }

  isDateString(str: string): boolean {
    const isoDatePattern = /^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2})?/;
    if (isoDatePattern.test(str)) return true;
    const parsed = Date.parse(str);
    return !isNaN(parsed);
  }

  getFieldPriority(fieldName: string, morphType: string): number {
    const basePriorities: Record<string, number> = {
      'name-morph': 900,
      'image-morph': 850,
      'tag-morph': 750,
      'text-morph': 700,
      'radar-chart-morph': 690,
      'range-morph': 680,
      'progress-morph': 670,
      'bar-chart-morph': 665,
      'sparkline-morph': 660,
      'pie-chart-morph': 655,
      'number-morph': 650,
      'key-value-morph': 620,
      'boolean-morph': 600,
      'list-morph': 550,
      'data-morph': 400,
      'map-morph': 350,
      'chart-morph': 300,
      'timeline-morph': 200,
    };

    let priority = basePriorities[morphType] || 500;

    const lowerName = fieldName.toLowerCase();
    
    // CRITICAL SAFETY INFO ‚Üí Highest priority
    if (lowerName.includes('edib') || lowerName.includes('toxic') || 
        lowerName.includes('poison') || lowerName.includes('deadly') ||
        lowerName.includes('lookalike') || lowerName.includes('danger')) {
      priority += 300;
    }
    
    // Identity terms ‚Üí boost priority
    if (lowerName.includes('name') || lowerName.includes('title')) {
      priority += 100;
    }
    
    // Visuelle Morphs (Range, Charts) ‚Üí Extra Boost!
    if (morphType === 'range-morph' || morphType === 'progress-morph' ||
        morphType.includes('chart') || morphType === 'sparkline-morph' ||
        morphType === 'radar-chart-morph' || morphType === 'key-value-morph') {
      priority += 120;
    }
    
    // Visual identification ‚Üí high priority
    if (lowerName.includes('color') || lowerName.includes('shape') || 
        lowerName.includes('spore') || lowerName.includes('cap') ||
        lowerName.includes('stem') || lowerName.includes('gill') ||
        lowerName.includes('diameter') || lowerName.includes('length') ||
        lowerName.includes('size') || lowerName.includes('temperature') ||
        lowerName.includes('humidity') || lowerName.includes('range')) {
      priority += 100;
    }
    
    // Metadata ‚Üí lowest priority
    if (lowerName.includes('created') || lowerName.includes('updated') || 
        lowerName.includes('modified') || lowerName.includes('_id') ||
        lowerName.includes('slug')) {
      priority -= 500;
    }

    return priority;
  }

  getMappedFields(entity: any, options: any = {}) {
    const {
      excludeFields = ['_id', '_creationTime', 'slug', 'seoName', 'imageUrls'],
      maxFields = 15,
      maxDepth = 1,
      currentDepth = 0,
      parentPath = ''
    } = options;

    const fields: Array<{ fieldName: string; morphType: string; value: any; priority: number; fullPath: string }> = [];

    // SPECIAL: Extract chart-ready fields from nested objects FIRST
    if (currentDepth === 0) {
      // Check culinaryAndNutritional.nutritionalProfile
      if (entity.culinaryAndNutritional?.nutritionalProfile) {
        fields.push({
          fieldName: 'nutritionalProfile',
          fullPath: 'culinaryAndNutritional.nutritionalProfile',
          morphType: 'radar-chart-morph',
          value: entity.culinaryAndNutritional.nutritionalProfile,
          priority: 800 // High priority for visual data
        });
      }

      // Check cultivationAndGrowing.cultivationTimeline
      if (entity.cultivationAndGrowing?.cultivationTimeline) {
        fields.push({
          fieldName: 'cultivationTimeline',
          fullPath: 'cultivationAndProcessing.cultivationTimeline',
          morphType: 'timeline-morph',
          value: entity.cultivationAndProcessing.cultivationTimeline,
          priority: 750
        });
      }

      // Check ecologyAndHabitat.geographicDistribution
      if (entity.ecologyAndHabitat?.geographicDistribution && 
          Array.isArray(entity.ecologyAndHabitat.geographicDistribution) &&
          entity.ecologyAndHabitat.geographicDistribution[0]?.location) {
        fields.push({
          fieldName: 'geographicDistribution',
          fullPath: 'ecologyAndHabitat.geographicDistribution',
          morphType: 'map-morph',
          value: entity.ecologyAndHabitat.geographicDistribution,
          priority: 700
        });
      }

      // Check ratings
      if (entity.ratings) {
        fields.push({
          fieldName: 'ratings',
          fullPath: 'ratings',
          morphType: 'progress-morph',
          value: entity.ratings,
          priority: 650
        });
      }
    }

    for (const [key, value] of Object.entries(entity)) {
      if (excludeFields.includes(key)) continue;
      if (value === null || value === undefined) continue;

      const fullPath = parentPath ? `${parentPath}.${key}` : key;
      const morphType = this.getMorphType(key, value);
      const priority = this.getFieldPriority(key, morphType);

      fields.push({
        fieldName: key,
        fullPath,
        morphType,
        value,
        priority
      });

      // F√ºr verschachtelte Objekte: data-morph handlet das
      // Keine Rekursion mehr, um Explosion zu vermeiden
    }

    // Sort by priority and limit
    const sorted = fields.sort((a, b) => b.priority - a.priority);
    return maxFields ? sorted.slice(0, maxFields) : sorted;
  }
}

const morphMapper = new ServerMorphMapper();
---

<BaseLayout 
  title="Entities - Funginomi AMORPH"
  description="Morphological Entity Database with perspectival views"
  enableGlow={false}
  enableSearch={true}
  enableAnimation={true}
>
  <!-- Page Header -->
  <header style="margin-bottom: 2rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem;">

      <p style="font-size: 0.74rem; color: rgba(255, 255, 255, 0.8);">
        {entities?.length || 0} Entities - Open Source
      </p>
    </div>
    
    <!-- View Toggle -->
    <div class="view-toggle">
      <button class="view-btn active" data-view="grid">
        üìä Grid View
      </button>
      <button class="view-btn" data-view="bubble">
        ü´ß Bubble View
      </button>
    </div>
  </header>

  <!-- Bubble Host -->
  <bubble-host id="bubble-view-host" style="display: none;"></bubble-host>

  <!-- Entity Grid -->
  <div class="entity-grid" id="grid-view-host">
    {entities && entities.length > 0 ? (
      entities.map((entity: any) => (
        <div class="entity-card" data-slug={entity.slug}>
          <div class="card-image">
            <image-morph 
              src={`/images/fungi/${entity.slug}.jpg`}
              alt={entity.commonName}
            ></image-morph>
            {entity.taxonomy && (
              <div class="image-overlay">
                {entity.taxonomy.family && (
                  <div class="taxonomy-badge">
                    <span class="taxonomy-label">Familie</span>
                    <span class="taxonomy-value">{entity.taxonomy.family}</span>
                  </div>
                )}
                {entity.taxonomy.genus && (
                  <div class="taxonomy-badge">
                    <span class="taxonomy-label">Gattung</span>
                    <span class="taxonomy-value">{entity.taxonomy.genus}</span>
                  </div>
                )}
              </div>
            )}
          </div>
          

          <div 
            class="card-data" 
            data-entity={JSON.stringify(entity)}
            data-use-mapper="true"
          >
            <!-- Morphs will be dynamically created by MorphMapper on client-side -->
          </div>

          <a href={`/fungi/${entity.slug}`} class="card-link">
            view fully ‚Üí
          </a>
        </div>
      ))
    ) : (
      <div class="empty-state">
        <p style="font-size: 1.5rem; color: rgba(255, 255, 255, 0.7); text-align: center;">
          üçÑ No entities found
        </p>
        <p style="color: rgba(255, 255, 255, 0.5); text-align: center; margin-top: 0.5rem;">
          Searching Database
        </p>
      </div>
    )}
  </div>
</BaseLayout>

<style>
  /* Wood Floor Background Card - Always visible */
  .entity-card {
    background: url('/images/woodfloor/Moss_Woodsf_Laub.png');
    background-size: cover;
    background-position: center;
    border-radius: 20px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.12);
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex;
    flex-direction: column;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
    height: auto;
    position: relative;
  }
  
  /* Dark overlay for better readability */
  .entity-card::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.64));
    pointer-events: none;
    z-index: 1;
    transition: background 0.4s ease;
  }
  
  .entity-card > * {
    position: relative;
    z-index: 2;
  }

  .entity-card:hover,
  .entity-card.touch-hover {
    transform: translateY(-8px) scale(1.02);
    box-shadow: 0 16px 48px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.1) inset;
    border-color: rgba(255, 255, 255, 0.2);
  }
  
  .entity-card:hover::before,
  .entity-card.touch-hover::before {
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.9));
  }

  .card-image {
    width: 100%;
    height: 0;
    padding-bottom: 75%; /* 4:3 aspect ratio - more compact */
    overflow: hidden;
    background: rgba(0, 0, 0, 0.2);
    position: relative;
  }

  .card-image image-morph {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  /* Force contain fit for images in cards */
  .card-image image-morph::part(image),
  .card-image image-morph .image,
  .card-image image-morph img {
    object-fit: contain !important;
  }

  .image-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(to top, rgba(0, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0.7) 50%, transparent 100%);
    padding: 0.75rem; /* Reduced padding */
    display: flex;
    gap: 0.75rem; /* Reduced gap */
    align-items: flex-end;
    z-index: 10;
  }

  .taxonomy-badge {
    display: flex;
    flex-direction: column;
    gap: 0.0625rem; /* Minimal gap */
  }

  .taxonomy-label {
    font-size: 0.5625rem; /* Smaller label */
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: rgba(255, 255, 255, 0.6);
  }

  .taxonomy-value {
    font-size: 0.8125rem; /* Smaller value */
    font-weight: 600;
    color: white;
    font-style: italic;
  }

  .card-header {
    padding: 1.25rem; /* Reduced from 2rem */
    backdrop-filter: none;
    flex-shrink: 0;
  }

  .card-header name-morph {
    display: block;
  }

  .card-header name-morph:first-child {
    margin-bottom: 0.5rem; /* Reduced from 0.75rem */
    font-size: 1.25rem; /* Slightly smaller */
    line-height: 1.3;
  }

  .quick-info {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.625rem 1rem; /* Reduced gaps */
    margin-top: 0.75rem; /* Reduced from 1rem */
    padding-top: 0.75rem; /* Reduced from 1rem */
  }

  .info-item {
    display: flex;
    flex-direction: column;
    gap: 0.1875rem; /* Reduced from 0.25rem */
    font-size: 0.8125rem;
  }

  .info-label {
    color: rgba(255, 255, 255, 0.5);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    font-size: 0.625rem; /* Slightly smaller */
  }

  .info-value {
    color: rgba(255, 255, 255, 0.95);
    font-weight: 600;
    font-size: 0.8125rem; /* Slightly smaller */
  }

  .card-data {
    padding: 1.5rem;
    display: grid;
    /* Smart 2-column grid: kleine Morphs nebeneinander, gro√üe volle Breite */
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem 0.875rem; /* Mehr vertikaler Abstand */
    overflow-y: auto;
    overflow-x: hidden;
    max-height: 450px;
    scrollbar-width: none;
    -ms-overflow-style: none;
    width: 100%;
    box-sizing: border-box;
  }
  
  /* Kompakte Morphs (Booleans, Numbers, kurze Tags) - Grid-fit */
  .card-data boolean-morph,
  .card-data number-morph {
    grid-column: span 1;
  }
  
  /* Volle Breite f√ºr komplexe/lange Morphs */
  .card-data data-morph,
  .card-data text-morph,
  .card-data list-morph,
  .card-data name-morph,
  .card-data tag-morph,
  .card-data range-morph,
  .card-data key-value-morph,
  .card-data .morph-field {
    grid-column: 1 / -1;
  }
  
  /* Kleine Tag-Morphs k√∂nnen auch compact sein */
  .card-data tag-morph.compact,
  .card-data .morph-field.compact {
    grid-column: span 1;
  }
  
  /* Enable flex ordering for perspective-based DataMorph positioning */
  .card-data data-morph {
    order: 999; /* Default: at bottom */
  }
  
  .card-data data-morph[style*="order"] {
    /* Custom order from perspective system takes precedence */
  }

  /* Hide scrollbar for Chrome/Safari/Opera */
  .card-data::-webkit-scrollbar {
    display: none;
  }

  /* Morph field wrapper with label */
  .card-data .morph-field {
    display: flex;
    flex-direction: column;
    gap: 0.375rem;
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
    overflow: hidden;
    padding-bottom: 0.25rem;
  }
  
  /* Kompakte morph-field wrapper f√ºr Boolean/Number */
  .card-data .morph-field:has(boolean-morph),
  .card-data .morph-field:has(number-morph) {
    grid-column: span 1;
  }
  
  .card-data .morph-label {
    font-size: 0.625rem;
    font-weight: 600;
    color: rgba(255, 255, 255, 0.5);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-bottom: 0.125rem;
  }
  
  /* Style all morph types in card-data */
  .card-data name-morph,
  .card-data text-morph,
  .card-data tag-morph,
  .card-data boolean-morph,
  .card-data number-morph,
  .card-data list-morph,
  .card-data data-morph,
  .card-data range-morph,
  .card-data key-value-morph {
    margin-bottom: 0;
    max-width: 100%;
    overflow: hidden;
    word-wrap: break-word;
    overflow-wrap: break-word;
  }
  
  /* Kompakte Darstellung f√ºr Boolean-Morphs im Grid */
  .card-data boolean-morph {
    display: flex;
    align-items: center;
    min-height: 2.5rem;
  }
  
  /* Kompakte Darstellung f√ºr Number-Morphs im Grid */
  .card-data number-morph {
    display: flex;
    align-items: flex-start;
    min-height: 2.5rem;
  }
  
  /* Legacy data-morph support */
  .card-data data-morph {
    order: 999; /* Default: hidden at bottom until perspective activates */
  }

  .card-link {
    display: block;
    padding: 0.875rem 1.25rem; /* Reduced padding */
    text-align: center;
    background: rgba(0, 0, 0, 0.2);
    backdrop-filter: blur(8px);
    color: rgba(255, 255, 255, 0.9);
    text-decoration: none;
    font-weight: 600;
    font-size: 0.8125rem; /* Slightly smaller */
    text-transform: uppercase;
    letter-spacing: 0.05em;
    transition: all 0.3s ease;
    margin-top: auto;
    flex-shrink: 0;
  }

  .card-link:hover {
    background: rgba(0, 0, 0, 0.7);
    color: #22c55e;
    box-shadow: 0 -2px 12px rgba(34, 197, 94, 0.3) inset, 0 0 20px rgba(34, 197, 94, 0.1);
  }

  /* View Toggle - Black Glassmorphism */
  .view-toggle {
    display: flex;
    gap: 0.5rem;
    background: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(16px);
    padding: 0.375rem;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.02) inset;
  }

  .view-btn {
    padding: 0.75rem 1.5rem;
    background: transparent;
    border: none;
    border-radius: 8px;
    color: rgba(255, 255, 255, 0.6);
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .view-btn:hover {
    background: rgba(0, 0, 0, 0.6);
    color: rgba(255, 255, 255, 0.9);
  }

  .view-btn.active {
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(8px);
    color: white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1) inset;
  }

  /* Bubble Host */
  #bubble-view-host {
    margin-bottom: 2rem;
  }

  /* Entity Grid */
  .entity-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
    gap: 2.5rem;
    margin-bottom: 4rem;
    padding: 1rem 0;
    align-items: start; /* Align cards to top for better visual balance */
  }
  
  /* Morphs */
  .morphs {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }
  
  /* Tags */
  .tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin: 0.5rem 0;
  }
  
  /* Detail Link */
  .detail-link {
    display: inline-block;
    margin-top: 1rem;
    padding: 0.5rem 1rem;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    text-decoration: none;
    border-radius: 8px;
    font-weight: 500;
    transition: all 0.2s ease;
  }
  
  .detail-link:hover {
    transform: translateX(4px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
  }
  
  /* Empty State */
  .empty-state {
    grid-column: 1 / -1;
    padding: 4rem 2rem;
    text-align: center;
  }
  
  /* Responsive */
  @media (max-width: 768px) {
    .entity-grid {
      grid-template-columns: 1fr;
      gap: 1.5rem;
    }
    
    .entity-card {
      padding: 1rem;
    }
    
    /* Auf kleinen Screens: Morphs untereinander, aber Booleans noch nebeneinander */
    .card-data {
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
      padding: 1rem;
    }
    
    /* Booleans bleiben kompakt nebeneinander */
    .card-data boolean-morph,
    .card-data number-morph {
      grid-column: span 1;
    }
    
    /* Alle anderen volle Breite */
    .card-data data-morph,
    .card-data text-morph,
    .card-data list-morph,
    .card-data name-morph,
    .card-data tag-morph,
    .card-data .morph-field:not(:has(boolean-morph)):not(:has(number-morph)) {
      grid-column: 1 / -1;
    }

    header {
      flex-direction: column;
      align-items: flex-start !important;
    }
  }
  
  /* Sehr kleine Cards: alles untereinander */
  @media (max-width: 320px) {
    .card-data {
      grid-template-columns: 1fr;
    }
    
    .card-data boolean-morph,
    .card-data number-morph {
      grid-column: 1 / -1;
    }
  }
  
  /* Dark Mode */
  @media (prefers-color-scheme: dark) {
    .entity-card {
      /* Keep wood floor background visible in dark mode */
      color: rgba(255, 255, 255, 0.9);
    }
  }
</style>

<script define:vars={{ entities, perspectiveDisplayFields }}>
  // ===========================================================================
  // üîç COMPREHENSIVE DEBUG LOGGING FOR MORPH CREATION
  // ===========================================================================
  const DEBUG_MORPH_FLOW = true;
  
  function debugLog(category, message, data = null) {
    if (!DEBUG_MORPH_FLOW) return;
    const prefix = `[üîç DEBUG:${category}]`;
    if (data !== null) {
      console.log(prefix, message, data);
    } else {
      console.log(prefix, message);
    }
  }
  
  debugLog('INIT', 'üì¶ perspectiveDisplayFields loaded:', Object.keys(perspectiveDisplayFields || {}));
  debugLog('INIT', 'üìä entities count:', entities?.length || 0);
  
  // Wait for AMORPH and hosts to load
  async function initViewToggle() {
    const amorph = window.amorph;
    if (!amorph) {
      debugLog('INIT', '‚è≥ Waiting for AMORPH...');
      setTimeout(initViewToggle, 100);
      return;
    }

    // Get host elements
    const bubbleHost = document.getElementById('bubble-view-host');
    const gridHost = document.getElementById('grid-view-host');
    
    if (!bubbleHost || !gridHost) {
      debugLog('INIT', '‚ö†Ô∏è Host elements not found, retrying...');
      setTimeout(initViewToggle, 100);
      return;
    }

    // Wait for bubbleHost to be fully upgraded (web component ready)
    if (!bubbleHost.setData) {
      console.log('‚è≥ Waiting for BubbleHost to upgrade...');
      setTimeout(initViewToggle, 100);
      return;
    }

    // DATENGETRIEBEN: Pass entity data to BubbleHost
    console.log('üìä Entity data:', entities);
    bubbleHost.setData(entities);
    console.log(`‚úÖ Passed ${entities.length} entities to BubbleHost`);

    // Enable connections by default for similarity visualization
    setTimeout(() => {
      const bubbleView = bubbleHost.shadowRoot?.querySelector('bubble-view');
      if (bubbleView) {
        bubbleView.showConnections = true;
        console.log('‚úÖ Enabled similarity-based connections in BubbleView');
      }
    }, 1000);

    // REMOVED: AstroDataSearchReactor - Replaced by SearchFilterController (see line 787-792)
    // SearchFilterController provides better performance and cleaner implementation

    // MorphHeader will initialize with 4 default perspectives automatically
    console.log('‚úÖ Perspectives will be initialized by MorphHeader');

    // FIFO Perspective Ordering System
    const perspectiveOrder = [];
    // NOW USING CENTRALIZED MAPPINGS from perspectiveFieldMappings.astro
    // When schema changes, only update perspectiveFieldMappings.astro!
    const perspectiveFieldMap = perspectiveDisplayFields;

    function updateDataMorphVisibility() {
      const cards = document.querySelectorAll('.card-data');
      
      cards.forEach((cardData) => {
        const morphs = Array.from(cardData.querySelectorAll('data-morph'));
        
        morphs.forEach(morph => {
          const field = morph.getAttribute('field');
          let order = 999;
          let shouldShow = false;
          
          // Check if this field belongs to any active perspective
          for (let i = 0; i < perspectiveOrder.length; i++) {
            const perspectiveName = perspectiveOrder[i];
            const fields = perspectiveFieldMap[perspectiveName] || [];
            if (fields.includes(field)) {
              shouldShow = true;
              order = i * 10;
              break;
            }
          }
          
          morph.style.order = order;
        });
      });
    }

    // Listen to perspective changes from MorphHeader
    // MorphHeader dispatches: window.dispatchEvent(new CustomEvent('perspective-changed', { detail: { perspectives } }))
    console.log('‚úÖ Setting up perspective-changed listener');
    
    const perspectiveHandler = (event) => {
      const perspectives = event.detail?.perspectives || [];
      
      console.log('üîÑ Perspective changed:', perspectives.map(p => p.name || p));
      
      // Update active perspective order
      perspectiveOrder.length = 0;
      perspectiveOrder.push(...perspectives.map(p => p.name || p));
      
      // Re-render morphs for active perspectives (data-driven!)
      if (window._renderMorphsForPerspectives) {
        window._renderMorphsForPerspectives(perspectives);
      }
      
      // Show/hide and reorder DataMorphs based on active perspectives
      updateDataMorphVisibility();
    };
    
    // Listen ONLY to window event (MorphHeader dispatches to both window and document)
    window.addEventListener('perspective-changed', perspectiveHandler);
    
    console.log('‚úÖ Perspective listeners registered');
    console.log('‚è≥ Waiting for MorphHeader to dispatch default perspectives...');

    // View Toggle functionality with coordinated state
    const viewBtns = document.querySelectorAll('.view-btn');
    let currentView = 'grid'; // Track current view

    viewBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        const view = btn.dataset.view;
        if (view === currentView) return; // Already on this view
        
        currentView = view;
        
        // Update active state
        viewBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Toggle views and activate appropriate reactors
        if (view === 'grid') {
          // Show Grid, Hide Bubble
          bubbleHost.style.display = 'none';
          gridHost.style.display = 'grid'; // Must be 'grid' not 'block'
          
          // Force reflow to ensure cards are visible
          void gridHost.offsetHeight;
          
          // Grid View: SearchFilterController handles search (already initialized)
          // Perspectives and search state are already shared via events
          
          const searchQuery = amorph.state.searchQuery || 'none';
          const perspectiveCount = amorph.state?.activePerspectives?.length || 0;
          console.log(`[ViewToggle] üìä Grid View | Search: "${searchQuery}" | Perspectives: ${perspectiveCount} active`);
          
        } else {
          // Show Bubble, Hide Grid
          gridHost.style.display = 'none';
          bubbleHost.style.display = 'block';
          
          // Bubble View: Enable Pixi.js rendering
          const bubbleView = bubbleHost.shadowRoot?.querySelector('bubble-view');
          if (bubbleView) {
            // BubbleView v2.0 - Pixi.js auto-renders, no manual reactor enabling needed
            // Similarity calculations happen automatically via backend
            
            const searchQuery = amorph.state.searchQuery || 'none';
            const perspectiveCount = amorph.state?.activePerspectives?.length || 0;
            console.log(`[ViewToggle] ü™∑ Bubble View v2.0 (Pixi.js) | Search: "${searchQuery}" | Perspectives: ${perspectiveCount} active`);
          }
          
          // Enable BubbleView-specific reactors
          if (window.amorph) {
            window.amorph.enableReactor('bubbleDetail');
            window.amorph.enableReactor('bubbleSearch');
            console.log('[ViewToggle] ‚úÖ Bubble reactors enabled (BubbleDetail, BubbleSearch)');
            
            // Trigger perspective update on all bubble morphs
            const bubbles = bubbleHost.shadowRoot?.querySelectorAll('bubble-morph') || [];
            bubbles.forEach(bubble => {
              if (window.amorph.state?.activePerspectives) {
                bubble.activePerspectives = window.amorph.state.activePerspectives;
                bubble.requestUpdate();
              }
            });
            if (bubbles.length > 0) {
              console.log(`[ViewToggle] üîÑ Updated ${bubbles.length} bubbles with active perspectives`);
            }
            
            // If there's an active search with cached results, apply to Bubble View
            const searchQuery = window.amorph.state?.searchQuery;
            const cachedResults = window.amorph.state?.searchResults;
            if (searchQuery && searchQuery.trim() !== '' && cachedResults && cachedResults.length > 0) {
              console.log('üîç [ViewToggle] Applying cached search to Bubble View:', searchQuery, `(${cachedResults.length} results)`);
              window.dispatchEvent(new CustomEvent('convex-search:completed', {
                detail: {
                  query: searchQuery,
                  results: cachedResults
                }
              }));
            } else if (searchQuery && searchQuery.trim() !== '') {
              console.log('‚ö†Ô∏è [ViewToggle] Search query exists but no cached results - skipping bubble creation');
            }
          }
        }
        
        // Both views share:
        // ‚úì Search query (via amorph.state.searchQuery and search:input events)
        // ‚úì Perspectives (via MorphHeader perspective-changed events)
        // ‚úì User interactions persist across view switches
      });
    });

    console.log('‚úÖ View toggle initialized with', entities.length, 'entities');
    console.log('‚úÖ Shared state: Search + Perspectives coordinated across views');
  }

  // Start initialization
  console.log('üöÄ Starting view toggle initialization...');
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initViewToggle);
  } else {
    initViewToggle();
  }
</script>

<!-- Search Filter Controller (NEW) -->
<script type="module">
  import { SearchFilterController } from '/src/amorph/features/search-system/SearchFilterController.js';
  
  // Initialize search filter for Grid View
  const searchFilter = new SearchFilterController('.entity-grid', '.entity-card');
  
  console.log('üîç SearchFilterController initialized for Grid View');
  
  // Enable CardScrollReactor for smart image shrinking on scroll
  (async () => {
    // Wait for AMORPH system to be ready
    while (!window.amorph || !window.amorph.hasReactor) {
      await new Promise(resolve => setTimeout(resolve, 50));
    }
    
    if (window.amorph.hasReactor('cardScroll')) {
      await window.amorph.enableReactor('cardScroll');
      console.log('‚úÖ CardScrollReactor enabled - Images will shrink horizontally on scroll');
    } else {
      console.warn('‚ö†Ô∏è CardScrollReactor not found - scrolling without image resize');
    }
  })();
</script>

<!-- Dynamic DataMorph Mode Switcher -->
<script type="module">
  /**
   * üîÑ DYNAMIC DATAMORPH MODE SWITCHER
   * ==================================
   * 
   * Switches data-morph display modes based on user interaction:
   * - Initial load: mode="simple" with relevant fields (10 fields max)
   * - After search: mode="deep" showing ALL matched data
   * - After perspective change: mode="deep" showing ALL perspective data
   * 
   * This gives users full context when searching/filtering while keeping
   * initial load clean and performant.
   */
  
  class DataMorphModeSwitcher {
    constructor() {
      this.isSearchActive = false;
      this.isPerspectiveActive = false;
      this.currentQuery = '';
      this.matchedFields = {};
      this.activePerspectives = [];
      
      this.init();
    }
    
    init() {
      // Wait for DOM
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => this.setup());
      } else {
        this.setup();
      }
    }
    
    setup() {
      console.log('[DataMorphModeSwitcher] üé¨ Initializing...');
      
      // Store original field values in dataset for restoration
      const dataMorphs = document.querySelectorAll('.card-data data-morph[field]');
      dataMorphs.forEach(morph => {
        const field = morph.getAttribute('field');
        if (field) {
          morph.dataset.originalField = field;
        }
      });
      
      // Listen for search events
      window.addEventListener('convex-search:completed', (event) => {
        this.handleSearchCompleted(event.detail);
      });
      
      window.addEventListener('convex-search:reset', () => {
        this.handleSearchReset();
      });
      
      // Listen for perspective changes (from MorphHeader)
      window.addEventListener('perspective-changed', (event) => {
        this.handlePerspectiveChange(event.detail);
      });
      
      console.log('[DataMorphModeSwitcher] ‚úÖ Ready - Listening for search and perspective events');
    }
    
    /**
     * Handle search completed - switch to deep mode
     */
    handleSearchCompleted(searchData) {
      const { query, results, matchedFields } = searchData;
      
      const fieldCount = matchedFields ? Object.keys(matchedFields).length : 0;
      console.log(`[DataMorphModeSwitcher] üîç Search "${query}" ‚Üí ${results?.length || 0} results (${fieldCount} with matched fields)`);
      
      // Update state
      this.isSearchActive = !!(query && query.trim().length >= 2);
      this.currentQuery = query || '';
      this.matchedFields = matchedFields || {};
      
      if (this.isSearchActive) {
        this.switchToDeepMode('search');
      } else {
        this.switchToSimpleMode();
      }
    }
    
    /**
     * Handle search reset - switch back to simple mode
     */
    handleSearchReset() {
      console.log('[DataMorphModeSwitcher] üîÑ Search reset');
      
      this.isSearchActive = false;
      this.currentQuery = '';
      this.matchedFields = {};
      
      // Only switch back to simple if no perspective is active
      if (!this.isPerspectiveActive) {
        this.switchToSimpleMode();
      }
    }
    
    /**
     * Handle perspective change - switch to deep mode
     */
    handlePerspectiveChange(data) {
      const { perspectives } = data || {};
      
      const perspectiveStr = perspectives?.join(', ') || 'none';
      console.log(`[DataMorphModeSwitcher] üé≠ Perspectives: ${perspectiveStr}`);
      
      this.isPerspectiveActive = !!(perspectives && perspectives.length > 0);
      this.activePerspectives = perspectives || [];
      
      if (this.isPerspectiveActive) {
        this.switchToDeepMode('perspective');
      } else if (!this.isSearchActive) {
        // Only switch back to simple if search is also inactive
        this.switchToSimpleMode();
      }
    }
    
    /**
     * Switch all visible cards to deep mode
     */
    switchToDeepMode(reason = 'unknown') {
      console.log(`[DataMorphModeSwitcher] üîÑ Switching to DEEP mode (reason: ${reason})`);
      
      // Get all visible cards (not hidden by search filter)
      const cards = document.querySelectorAll('.entity-card');
      let updatedCount = 0;
      
      cards.forEach(card => {
        // Skip hidden cards
        if (card.style.display === 'none') return;
        
        // Get all data-morphs in this card
        const dataMorphs = card.querySelectorAll('.card-data data-morph');
        
        dataMorphs.forEach((morph, index) => {
          if (index === 0) {
            // First morph: switch to deep mode (will render ALL perspectives)
            morph.setAttribute('mode', 'deep');
            morph.removeAttribute('field');
            morph.style.display = '';
            
            // Force re-render by triggering extractData
            if (morph.extractData && typeof morph.extractData === 'function') {
              morph.extractData();
            }
            
            updatedCount++;
          } else {
            // Other morphs: hide them to prevent duplication
            morph.style.display = 'none';
          }
        });
      });
      
      console.log(`[DataMorphModeSwitcher] ‚úÖ Updated ${updatedCount} cards to deep mode (hidden ${cards.length - updatedCount} duplicate morphs)`);
      
      // Dispatch event to notify highlighting system
      // CRITICAL: Only dispatch if auto-activation is NOT in progress
      // If auto-activation is running, MorphHeader will dispatch after it completes
      setTimeout(() => {
        const morphHeader = document.querySelector('morph-header');
        const isAutoActivating = morphHeader?._isAutoActivating || false;
        
        if (isAutoActivating) {
          console.log('[DataMorphModeSwitcher] ‚è≠Ô∏è Skipping deep-mode-ready dispatch - auto-activation in progress');
          return;
        }
        
        console.log('[DataMorphModeSwitcher] üì§ Dispatching deep-mode-ready');
        window.dispatchEvent(new CustomEvent('data-morph:deep-mode-ready', {
          detail: { reason }
        }));
      }, 100);
    }
    
    /**
     * Switch all cards back to simple mode with relevant fields
     */
    switchToSimpleMode() {
      console.log('[DataMorphModeSwitcher] üìÑ Switching to SIMPLE mode (relevant fields)');
      
      // Get all cards
      const cards = document.querySelectorAll('.entity-card');
      let updatedCount = 0;
      
      cards.forEach(card => {
        // Get all data-morphs in this card
        const dataMorphs = card.querySelectorAll('.card-data data-morph');
        
        dataMorphs.forEach((morph, index) => {
          // Show all morphs again (they were hidden in deep mode)
          morph.style.display = '';
          
          // Remove deep mode
          if (morph.hasAttribute('mode')) {
            morph.removeAttribute('mode');
          }
          
          // Restore field attribute from original field (stored in dataset)
          const originalField = morph.dataset.originalField;
          if (originalField) {
            morph.setAttribute('field', originalField);
          }
          
          updatedCount++;
        });
      });
      
      console.log(`[DataMorphModeSwitcher] ‚úÖ Updated ${updatedCount} data-morphs to simple mode`);
    }
  }
  
  // Initialize
  new DataMorphModeSwitcher();
</script>

<!-- MorphMapper Client-Side Initialization -->
<script type="module">
  /**
   * üó∫Ô∏è MORPH MAPPER CLIENT INITIALIZATION
   * ======================================
   * 
   * Dynamically creates morph elements based on data attributes
   * using the MorphMapper to select the correct morph type
   */
  
  // Debug helper
  const DEBUG = true;
  function dbg(msg, data = null) {
    if (!DEBUG) return;
    if (data !== null) {
      console.log(`[üîç MorphMapper:DEBUG] ${msg}`, data);
    } else {
      console.log(`[üîç MorphMapper:DEBUG] ${msg}`);
    }
  }
  
  async function initMorphMapper() {
    dbg('üöÄ initMorphMapper called');
    
    // Wait for MorphMapper to be available
    await new Promise(resolve => {
      if (window.amorph?.morphMapper) {
        dbg('‚úÖ MorphMapper already available');
        resolve();
      } else {
        dbg('‚è≥ Waiting for MorphMapper...');
        const checkInterval = setInterval(() => {
          if (window.amorph?.morphMapper) {
            dbg('‚úÖ MorphMapper now available');
            clearInterval(checkInterval);
            resolve();
          }
        }, 100);
      }
    });

    const mapper = window.amorph.morphMapper;
    console.log('[MorphMapper] ‚úÖ Client initialization starting...');
    dbg('MorphMapper instance:', mapper);

    // Find all card-data containers that need dynamic morphs
    const containers = document.querySelectorAll('.card-data[data-use-mapper="true"]');
    dbg(`Found ${containers.length} card-data containers`);
    
    if (containers.length === 0) {
      console.warn('[MorphMapper] ‚ö†Ô∏è No card-data containers found with data-use-mapper="true"');
      dbg('Searching for any .card-data elements...', document.querySelectorAll('.card-data').length);
    }
    
    // Store containers for later rendering
    window._cardContainers = containers;
    
    // Track if morphs have been created for each container
    const initializedContainers = new WeakSet();
    
    // Function to render morphs based on active perspectives
    function renderMorphsForPerspectives(activePerspectives = []) {
      dbg('üé® renderMorphsForPerspectives called', { 
        perspectives: activePerspectives?.map(p => p.name || p),
        containerCount: containers.length 
      });
      console.log(`[MorphMapper] üé® Updating visibility for ${activePerspectives.length} perspectives`);
      
      let totalMorphsCreated = 0;
      let totalMorphsShown = 0;
      let totalMorphsHidden = 0;
      
      containers.forEach((container, containerIdx) => {
        try {
          const entityDataStr = container.getAttribute('data-entity');
          if (!entityDataStr) {
            dbg(`Container ${containerIdx}: NO data-entity attribute!`);
            return;
          }

          const entityData = JSON.parse(entityDataStr);
          dbg(`Container ${containerIdx}: Entity "${entityData.slug || entityData._id}"`, {
            hasIdentity: !!entityData.identity,
            hasTaxonomy: !!entityData.taxonomy,
            hasMorphology: !!entityData.morphology,
            hasSensoryProfile: !!entityData.sensoryProfile,
            keys: Object.keys(entityData).slice(0, 10)
          });
          
          // Get active perspective names
          const activePerspectiveNames = activePerspectives.map(p => p.name || p);
          
          // FIRST TIME: Create ALL morphs from ALL perspectives (hidden by default)
          if (!initializedContainers.has(container)) {
            dbg(`Container ${containerIdx}: FIRST INIT - creating all morphs`);
            console.log('[MorphMapper] üÜï First load - creating all morphs');
            
            // Map schema field names to perspective IDs
            // These MUST match the perspectiveIds in perspectiveFieldMappings.ts!
            const perspectiveFieldMapping = {
              // Direct matches (perspectiveId === fieldName)
              'identity': 'identity',
              'visualIdentity': 'visualIdentity',
              'taxonomy': 'taxonomy',
              'phylogeny': 'phylogeny',
              'sensoryProfile': 'sensoryProfile',
              'temporalPatterns': 'temporalPatterns',
              'safetyAndIdentification': 'safetyAndIdentification',
              'metadata': 'metadata',
              // Schema fields that need mapping (schema fieldName -> perspectiveId)
              'morphology': 'morphologyAndAnatomy',
              'morphologyAndAnatomy': 'morphologyAndAnatomy',
              'microscopy': 'microscopyAndCellular',
              'microscopyAndCellular': 'microscopyAndCellular',
              'chemistry': 'chemicalAndProperties',
              'chemicalUniverse': 'chemicalAndProperties',
              'chemicalAndProperties': 'chemicalAndProperties',
              'ecology': 'ecologyAndDistribution',
              'ecologicalNetwork': 'ecologyAndDistribution',
              'ecologyAndDistribution': 'ecologyAndDistribution',
              'geography': 'geographyAndDistribution',
              'geographyAndDistribution': 'geographyAndDistribution',
              'cultivation': 'cultivationAndGrowing',
              'cultivationIntelligence': 'cultivationAndGrowing',
              'cultivationAndGrowing': 'cultivationAndGrowing',
              'medicinal': 'medicinalAndHealth',
              'medicinalIntelligence': 'medicinalAndHealth',
              'medicinalAndHealth': 'medicinalAndHealth',
              'culinary': 'culinaryAndNutritional',
              'culinaryDimensions': 'culinaryAndNutritional',
              'culinaryAndNutritional': 'culinaryAndNutritional',
              'economics': 'commercialAndMarket',
              'economicDimensions': 'commercialAndMarket',
              'commercialAndMarket': 'commercialAndMarket',
              'conservation': 'environmentalAndConservation',
              'environmentalIntelligence': 'environmentalAndConservation',
              'environmentalAndConservation': 'environmentalAndConservation',
              'cultural': 'historicalAndCultural',
              'culturalDimensions': 'historicalAndCultural',
              'historicalAndCultural': 'historicalAndCultural',
              'research': 'researchAndInnovation',
              'knowledgeConnections': 'researchAndInnovation',
              'researchAndInnovation': 'researchAndInnovation',
            };
            
            // Get all entity fields that could be perspectives
            const entityFields = Object.keys(entityData).filter(key => 
              !['_id', 'slug', 'names', 'images', 'tags', 'description', '_creationTime'].includes(key)
            );
            
            dbg(`Container ${containerIdx}: checking ${entityFields.length} entity fields`);
            
            let perspectivesWithData = 0;
            entityFields.forEach(fieldName => {
              let perspectiveData = entityData[fieldName];
              
              if (!perspectiveData || typeof perspectiveData !== 'object') {
                // dbg(`  ${fieldName}: no data`);
                return;
              }
              
              // Get the mapped perspective ID (normalize schema field names to consistent IDs)
              const perspectiveId = perspectiveFieldMapping[fieldName] || fieldName;
              
              // Debug: Show raw data structure before any processing
              const rawKeys = Object.keys(perspectiveData);
              dbg(`  ${fieldName}: RAW structure has ${rawKeys.length} keys:`, rawKeys.slice(0, 5));
              
              // CRITICAL: Unwrap citedValue wrapper { value: {...}, sources: [...], confidence: ... }
              // citedValue format: { value: <actual data>, sources: [...], confidence: number, ... }
              if ('value' in perspectiveData && ('sources' in perspectiveData || 'confidence' in perspectiveData || 'consensus' in perspectiveData || 'last_updated' in perspectiveData)) {
                dbg(`  ${fieldName} (‚Üí${perspectiveId}): unwrapping citedValue, value type:`, typeof perspectiveData.value);
                perspectiveData = perspectiveData.value;
                if (perspectiveData && typeof perspectiveData === 'object') {
                  dbg(`    After unwrap: ${Object.keys(perspectiveData).length} keys:`, Object.keys(perspectiveData).slice(0, 5));
                }
              }
              
              if (!perspectiveData || typeof perspectiveData !== 'object') {
                dbg(`  ${fieldName}: data became null/invalid after unwrap (type: ${typeof perspectiveData})`);
                return;
              }
              
              // Check if the unwrapped data is empty
              const dataKeys = Object.keys(perspectiveData);
              if (dataKeys.length === 0) {
                dbg(`  ${fieldName}: data object is EMPTY after unwrap!`);
                return;
              }
              
              perspectivesWithData++;
              
              const perspectiveFields = mapper.getMappedFields(perspectiveData, {
                maxFields: null,
                maxDepth: 2
              });
              
              if (perspectiveFields.length > 0) {
                dbg(`  ${fieldName} (‚Üí${perspectiveId}): ${perspectiveFields.length} fields ‚Üí creating morphs`);
                console.log(`[MorphMapper] üìä ${fieldName} ‚Üí ${perspectiveId}: ${perspectiveFields.length} fields found`);
                
                perspectiveFields.forEach(field => {
                  const fieldPath = `${fieldName}.${field.fullPath}`;
                  try {
                    const morphElement = mapper.createMorphElement(field, field.value || entityData);
                    if (!morphElement) {
                      dbg(`    ‚ö†Ô∏è createMorphElement returned null for ${field.fieldName}`);
                      return;
                    }
                    morphElement.setAttribute('data-priority', field.priority);
                    morphElement.setAttribute('data-morph-type', field.morphType);
                    morphElement.setAttribute('data-field-path', fieldPath);
                    morphElement.setAttribute('data-perspective', perspectiveId); // Mapped perspective ID
                    morphElement.setAttribute('perspective', perspectiveId); // CRITICAL: for PerspectiveReactor color bars
                    morphElement.style.display = 'none'; // Hidden by default
                    container.appendChild(morphElement);
                    totalMorphsCreated++;
                  } catch (morphError) {
                    console.error(`[MorphMapper] Error creating morph for ${field.fieldName}:`, morphError);
                  }
                });
              } else {
                dbg(`  ${fieldName}: 0 fields extracted`);
                console.log(`[MorphMapper] ‚ö†Ô∏è ${fieldName}: NO fields extracted (data exists but empty?)`);
              }
            });
            
            dbg(`Container ${containerIdx}: ${perspectivesWithData} perspectives had data, ${totalMorphsCreated} morphs created so far`);
            
            initializedContainers.add(container);
            container.dataset.fullData = entityDataStr;
          }
          
          // SHOW/HIDE morphs based on active perspectives (CSS only - super fast!)
          const allMorphs = Array.from(container.querySelectorAll('[data-perspective]'));
          
          if (activePerspectives.length === 0) {
            // Hide all morphs
            allMorphs.forEach(morph => {
              morph.style.display = 'none';
              totalMorphsHidden++;
            });
          } else {
            // Show morphs from active perspectives, hide others
            allMorphs.forEach(morph => {
              const morphPerspective = morph.getAttribute('perspective'); // Use 'perspective' not 'data-perspective'
              if (activePerspectiveNames.includes(morphPerspective)) {
                morph.style.display = '';
                totalMorphsShown++;
              } else {
                morph.style.display = 'none';
                totalMorphsHidden++;
              }
            });
          }
          
        } catch (error) {
          console.error('[MorphMapper] Error updating morphs:', error);
        }
      });

      if (totalMorphsCreated > 0) {
        console.log(`[MorphMapper] ‚úÖ Created ${totalMorphsCreated} morphs (one-time initialization)`);
      }
      
      // Debug: Show which perspectives morphs belong to vs which are active
      const allCreatedMorphs = document.querySelectorAll('.card-data [data-perspective]');
      const createdPerspectives = new Set();
      allCreatedMorphs.forEach(m => createdPerspectives.add(m.getAttribute('perspective')));
      dbg('üìä Summary:', {
        createdMorphs: allCreatedMorphs.length,
        createdPerspectives: Array.from(createdPerspectives),
        activePerspectives: activePerspectives.map(p => p.name || p),
        match: Array.from(createdPerspectives).some(p => activePerspectives.map(ap => ap.name || ap).includes(p))
      });
      
      console.log(`[MorphMapper] üëÅÔ∏è Visibility update: ${totalMorphsShown} shown, ${totalMorphsHidden} hidden (CSS only - instant)`);
    }
    
    // Store render function globally for perspective changes
    window._renderMorphsForPerspectives = renderMorphsForPerspectives;
    
    // DON'T render yet - wait for MorphHeader to dispatch default perspectives
    console.log('[MorphMapper] ‚è≥ Waiting for perspective-changed event...');
    
    // Debounce for card expansion/collapse (prevent re-render on every keystroke)
    let expansionTimer = null;
    let collapseTimer = null;
    let isExpanded = false;
    
    // PERFORMANCE FIX: Don't expand cards on search - morphs already exist and are visible/hidden by CSS
    // Highlighting works on visible morphs only (SearchFilterController handles this)
    // This prevents creating hundreds of morphs from ALL 12 perspectives on every search
    window.addEventListener('convex-search:completed', (event) => {
      // No-op - morphs already exist, SearchFilterController will highlight visible ones
      console.log('[MorphMapper] üéØ Search completed - using existing morphs (no expansion needed)');
    });
    
    window.addEventListener('convex-search:reset', () => {
      // No-op - morphs stay as they are, perspectives control visibility
      console.log('[MorphMapper] üîÑ Search reset - morphs remain (CSS controls visibility)');
    });
  }
  
  // Expand cards to show ALL fields during search (from ALL perspectives)
  function expandCardsForSearch(containers, mapper) {
    console.log('[MorphMapper] üîç Expanding cards to show ALL fields from ALL perspectives...');
    
    const allPerspectives = [
      'identity', 'visualIdentity', 'taxonomy', 'phylogeny', 'morphologyAndAnatomy',
      'microscopyAndCellular', 'chemicalAndProperties', 'sensoryProfile',
      'ecologyAndDistribution', 'temporalPatterns', 'geographyAndDistribution',
      'cultivationAndGrowing', 'medicinalAndHealth', 'culinaryAndNutritional',
      'commercialAndMarket', 'environmentalAndConservation', 'historicalAndCultural',
      'researchAndInnovation', 'safetyAndIdentification', 'metadata'
    ];
    
    containers.forEach(container => {
      const entityDataStr = container.dataset.fullData;
      if (!entityDataStr) return;
      
      const entityData = JSON.parse(entityDataStr);
      
      // Remove existing morphs
      container.innerHTML = '';
      
      const allFields = [];
      
      // Extract fields from ALL perspectives for search
      allPerspectives.forEach(perspectiveName => {
        const perspectiveData = entityData[perspectiveName];
        
        if (perspectiveData && typeof perspectiveData === 'object') {
          const fields = mapper.getMappedFields(perspectiveData, {
            maxFields: null,
            maxDepth: 2
          });
          
          fields.forEach(field => {
            field.perspective = perspectiveName;
            allFields.push(field);
          });
        }
      });
      
      // Sort by priority
      allFields.sort((a, b) => b.priority - a.priority);
      
      // Create morphs for ALL fields
      allFields.forEach(fieldConfig => {
        const morphElement = mapper.createMorphElement(fieldConfig, fieldConfig.value || entityData);
        morphElement.setAttribute('data-priority', fieldConfig.priority);
        morphElement.setAttribute('data-morph-type', fieldConfig.morphType);
        morphElement.setAttribute('data-field-path', fieldConfig.fullPath);
        morphElement.setAttribute('data-perspective', fieldConfig.perspective);
        morphElement.classList.add('search-expanded');
        container.appendChild(morphElement);
      });
    });
  }
  
  // Collapse cards back to active perspectives
  function collapseCardsToNormal(containers) {
    console.log('[MorphMapper] üìÑ Collapsing cards back to active perspectives...');
    
    // Get active perspectives from window event system
    const activePerspectives = window.amorph?.state?.activePerspectives || [];
    
    // Re-render with active perspectives
    if (window._renderMorphsForPerspectives) {
      window._renderMorphsForPerspectives(activePerspectives);
    }
  }
  
  // Legacy collapse function (kept for compatibility)
  function collapseCardsToNormalLegacy(containers) {
    const mapper = window.amorph.morphMapper;
    
    containers.forEach(container => {
      // Skip if already collapsed (check for search-expanded class)
      const hasExpandedMorphs = container.querySelector('.search-expanded');
      if (!hasExpandedMorphs) {
        console.log('[MorphMapper] ‚è≠Ô∏è Already collapsed, skipping');
        return;
      }
      
      const entityDataStr = container.dataset.fullData;
      if (!entityDataStr) return;
      
      const entityData = JSON.parse(entityDataStr);
      
      // Get top 15 fields only
      const topFields = mapper.getMappedFields(entityData, {
        maxFields: 15,
        maxDepth: 1
      });
      
      // Use requestAnimationFrame to prevent blocking UI
      requestAnimationFrame(() => {
        // Remove existing morphs
        container.innerHTML = '';
        
        // Create morphs for top fields only
        topFields.forEach(fieldConfig => {
          const morphElement = mapper.createMorphElement(fieldConfig, entityData);
          morphElement.setAttribute('data-priority', fieldConfig.priority);
          morphElement.setAttribute('data-morph-type', fieldConfig.morphType);
          morphElement.setAttribute('data-field-path', fieldConfig.fullPath);
          container.appendChild(morphElement);
        });
        
        console.log('[MorphMapper] ‚úÖ Collapsed to top 15 fields');
      });
    });
  }

  // Start initialization
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initMorphMapper);
  } else {
    initMorphMapper();
  }
</script>

<!-- Touch Hover Effects -->
<script type="module">
  // Touch-friendly hover effects for mobile scrolling
  function initTouchHover() {
    const cards = document.querySelectorAll('.entity-card');
    let lastTouchedCard = null;
    
    cards.forEach(card => {
      // Touch start - add hover class
      card.addEventListener('touchstart', (e) => {
        // Remove hover from previously touched card
        if (lastTouchedCard && lastTouchedCard !== card) {
          lastTouchedCard.classList.remove('touch-hover');
        }
        
        // Add hover to current card
        card.classList.add('touch-hover');
        lastTouchedCard = card;
      }, { passive: true });
      
      // Touch end - keep hover until next card is touched
      card.addEventListener('touchend', () => {
        // Don't remove hover - it stays until another card is touched
      }, { passive: true });
    });
  }
  
  // Initialize after DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTouchHover);
  } else {
    initTouchHover();
  }
  
  console.log('üëÜ Touch-friendly hover initialized');
</script>
