---
/**
 * üçÑ ENTITY INDEX PAGE
 * ===================
 * 
 * Main page showing all entities with AMORPH morphs
 * Loads real data from Convex
 * Uses MorphMapper for intelligent morph type selection
 */

import BaseLayout from '@/amorph/core/layouts/BaseLayout.astro';
import { fetchEntities } from '@/amorph/core/convex';

// Fetch entity data from Convex
const entities = await fetchEntities();

console.log(`üìä Loaded ${entities?.length || 0} entities from Convex`);

/**
 * MorphMapper - Server-side version
 * Determines correct morph type for each field - DATA DRIVEN!
 * Synchronized with client-side MorphMapper.js logic
 */
class ServerMorphMapper {
  constructor() {
    // NO hardcoded mappings - everything is data-driven!
  }

  getMorphType(fieldName: string, value: any): string {
    return this.getMorphByValueAnalysis(value, fieldName);
  }

  getMorphByValueAnalysis(value: any, fieldName: string = ''): string {
    if (value === null || value === undefined) {
      return 'text-morph';
    }

    const type = typeof value;

    // Boolean values ‚Üí BooleanMorph
    if (type === 'boolean') {
      return 'boolean-morph';
    }

    // Number values ‚Üí NumberMorph
    if (type === 'number') {
      return 'number-morph';
    }

    // String values - analyze content structure
    if (type === 'string') {
      const trimmed = value.trim();
      
      if (trimmed.length === 0) return 'text-morph';
      
      // Image URL detection
      if (this.isImageUrl(trimmed)) return 'image-morph';
      
      // Date/Time detection
      if (this.isDateString(trimmed)) return 'timeline-morph';
      
      // Short strings
      if (trimmed.length < 30 && !trimmed.includes('\n')) {
        if (trimmed.length < 15) return 'tag-morph';
        return 'name-morph';
      }
      
      return 'text-morph';
    }

    // Array values
    if (Array.isArray(value)) {
      if (value.length === 0) return 'list-morph';

      const firstItem = value[0];
      const itemType = typeof firstItem;
      
      // Array of strings
      if (itemType === 'string') {
        const avgLength = value.reduce((sum: number, item: any) => sum + (item?.length || 0), 0) / value.length;
        if (avgLength < 20) return 'tag-morph';
        return 'list-morph';
      }

      // Array of numbers
      if (itemType === 'number') {
        if (value.length < 5) return 'list-morph';
        if (value.length >= 5 && value.length <= 15) return 'sparkline-morph';
        return 'list-morph';
      }

      // Array of objects - NUR f√ºr strukturierte Chart-Daten
      if (itemType === 'object' && firstItem !== null) {
        const keys = Object.keys(firstItem);
        const isSimpleObject = keys.length >= 2 && keys.length <= 3;
        
        const allSameStructure = value.every((item: any) => {
          if (typeof item !== 'object' || item === null) return false;
          const itemKeys = Object.keys(item);
          return itemKeys.length === keys.length && itemKeys.every(k => keys.includes(k));
        });
        
        if (isSimpleObject && allSameStructure) {
          if (value.length >= 3 && value.length <= 6 &&
              (keys.includes('axis') || keys.includes('dimension') || keys.includes('label')) &&
              (keys.includes('value') || keys.includes('score') || keys.includes('rating'))) {
            return 'radar-chart-morph';
          }
          
          if (value.length >= 2 && value.length <= 6 &&
              (keys.includes('category') || keys.includes('type') || keys.includes('name')) &&
              (keys.includes('count') || keys.includes('percentage') || keys.includes('value'))) {
            return 'pie-chart-morph';
          }
          
          if (value.length >= 3 && value.length <= 8 &&
              (keys.includes('label') || keys.includes('month') || keys.includes('period')) &&
              (keys.includes('value') || keys.includes('amount'))) {
            return 'bar-chart-morph';
          }
        }
        
        return 'list-morph';
      }

      return 'list-morph';
    }

    // Object values
    if (type === 'object' && value !== null) {
      if (value instanceof Date) return 'timeline-morph';
      
      if (('lat' in value && 'lng' in value) || 
          ('latitude' in value && 'longitude' in value)) {
        return 'map-morph';
      }

      // Range object (min/max)
      if ('min' in value && 'max' in value) {
        return 'range-morph';
      }

      // Progress object
      if (('value' in value && 'max' in value) || 'percentage' in value) {
        return 'progress-morph';
      }

      // Small flat objects
      const primitiveFields = Object.entries(value).filter(([_, v]) => 
        typeof v !== 'object' || v === null
      );
      const hasNestedObjects = Object.values(value).some((v: any) => 
        typeof v === 'object' && v !== null && !Array.isArray(v)
      );
      const hasArrays = Object.values(value).some((v: any) => Array.isArray(v));
      
      if (primitiveFields.length > 0 && primitiveFields.length <= 5 && 
          !hasNestedObjects && !hasArrays && primitiveFields.length === Object.keys(value).length) {
        return 'key-value-morph';
      }

      return 'data-morph';
    }

    return 'text-morph';
  }

  isImageUrl(str: string): boolean {
    const imageExtensions = /\.(jpg|jpeg|png|gif|webp|svg|ico|bmp)$/i;
    const hasImageExtension = imageExtensions.test(str);
    const isUrlLike = str.startsWith('http') || str.startsWith('/') || str.startsWith('data:image');
    return isUrlLike && (hasImageExtension || str.includes('image') || str.startsWith('data:image'));
  }

  isDateString(str: string): boolean {
    const isoDatePattern = /^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2})?/;
    if (isoDatePattern.test(str)) return true;
    const parsed = Date.parse(str);
    return !isNaN(parsed);
  }

  getFieldPriority(fieldName: string, morphType: string): number {
    const basePriorities: Record<string, number> = {
      'name-morph': 900,
      'image-morph': 850,
      'tag-morph': 750,
      'text-morph': 700,
      'radar-chart-morph': 690,
      'range-morph': 680,
      'progress-morph': 670,
      'bar-chart-morph': 665,
      'sparkline-morph': 660,
      'pie-chart-morph': 655,
      'number-morph': 650,
      'key-value-morph': 620,
      'boolean-morph': 600,
      'list-morph': 550,
      'data-morph': 400,
      'map-morph': 350,
      'chart-morph': 300,
      'timeline-morph': 200,
    };

    let priority = basePriorities[morphType] || 500;

    const lowerName = fieldName.toLowerCase();
    
    // CRITICAL SAFETY INFO ‚Üí Highest priority
    if (lowerName.includes('edib') || lowerName.includes('toxic') || 
        lowerName.includes('poison') || lowerName.includes('deadly') ||
        lowerName.includes('lookalike') || lowerName.includes('danger')) {
      priority += 300;
    }
    
    // Identity terms ‚Üí boost priority
    if (lowerName.includes('name') || lowerName.includes('title')) {
      priority += 100;
    }
    
    // Visuelle Morphs (Range, Charts) ‚Üí Extra Boost!
    if (morphType === 'range-morph' || morphType === 'progress-morph' ||
        morphType.includes('chart') || morphType === 'sparkline-morph' ||
        morphType === 'radar-chart-morph' || morphType === 'key-value-morph') {
      priority += 120;
    }
    
    // Visual identification ‚Üí high priority
    if (lowerName.includes('color') || lowerName.includes('shape') || 
        lowerName.includes('spore') || lowerName.includes('cap') ||
        lowerName.includes('stem') || lowerName.includes('gill') ||
        lowerName.includes('diameter') || lowerName.includes('length') ||
        lowerName.includes('size') || lowerName.includes('temperature') ||
        lowerName.includes('humidity') || lowerName.includes('range')) {
      priority += 100;
    }
    
    // Metadata ‚Üí lowest priority
    if (lowerName.includes('created') || lowerName.includes('updated') || 
        lowerName.includes('modified') || lowerName.includes('_id') ||
        lowerName.includes('slug')) {
      priority -= 500;
    }

    return priority;
  }

  getMappedFields(entity: any, options: any = {}) {
    const {
      excludeFields = ['_id', '_creationTime', 'slug', 'seoName', 'imageUrls'],
      maxFields = 15,
      maxDepth = 1,
      currentDepth = 0,
      parentPath = ''
    } = options;

    const fields: Array<{ fieldName: string; morphType: string; value: any; priority: number; fullPath: string }> = [];

    for (const [key, value] of Object.entries(entity)) {
      if (excludeFields.includes(key)) continue;
      if (value === null || value === undefined) continue;

      const fullPath = parentPath ? `${parentPath}.${key}` : key;
      const morphType = this.getMorphType(key, value);
      const priority = this.getFieldPriority(key, morphType);

      fields.push({
        fieldName: key,
        fullPath,
        morphType,
        value,
        priority
      });

      // F√ºr verschachtelte Objekte: data-morph handlet das
      // Keine Rekursion mehr, um Explosion zu vermeiden
    }

    // Sort by priority and limit
    const sorted = fields.sort((a, b) => b.priority - a.priority);
    return maxFields ? sorted.slice(0, maxFields) : sorted;
  }
}

const morphMapper = new ServerMorphMapper();
---

<BaseLayout 
  title="Entities - Funginomi AMORPH"
  description="Morphological Entity Database with perspectival views"
  enableGlow={false}
  enableSearch={true}
  enableAnimation={true}
>
  <!-- Page Header -->
  <header style="margin-bottom: 2rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem;">

      <p style="font-size: 0.74rem; color: rgba(255, 255, 255, 0.8);">
        {entities?.length || 0} Entities - Open Source
      </p>
    </div>
    
    <!-- View Toggle -->
    <div class="view-toggle">
      <button class="view-btn active" data-view="grid">
        üìä Grid View
      </button>
      <button class="view-btn" data-view="bubble">
        ü´ß Bubble View
      </button>
    </div>
  </header>

  <!-- Bubble Host -->
  <bubble-host id="bubble-view-host" style="display: none;"></bubble-host>

  <!-- Entity Grid -->
  <div class="entity-grid" id="grid-view-host">
    {entities && entities.length > 0 ? (
      entities.map((entity: any) => (
        <div class="entity-card" data-slug={entity.slug}>
          <div class="card-image">
            <image-morph 
              src={`/images/fungi/${entity.slug}.jpg`}
              alt={entity.commonName}
            ></image-morph>
            {entity.taxonomy && (
              <div class="image-overlay">
                {entity.taxonomy.family && (
                  <div class="taxonomy-badge">
                    <span class="taxonomy-label">Familie</span>
                    <span class="taxonomy-value">{entity.taxonomy.family}</span>
                  </div>
                )}
                {entity.taxonomy.genus && (
                  <div class="taxonomy-badge">
                    <span class="taxonomy-label">Gattung</span>
                    <span class="taxonomy-value">{entity.taxonomy.genus}</span>
                  </div>
                )}
              </div>
            )}
          </div>
          

          <div 
            class="card-data" 
            data-entity={JSON.stringify(entity)}
            data-use-mapper="true"
          >
            <!-- Morphs will be dynamically created by MorphMapper on client-side -->
          </div>

          <a href={`/fungi/${entity.slug}`} class="card-link">
            view fully ‚Üí
          </a>
        </div>
      ))
    ) : (
      <div class="empty-state">
        <p style="font-size: 1.5rem; color: rgba(255, 255, 255, 0.7); text-align: center;">
          üçÑ No entities found
        </p>
        <p style="color: rgba(255, 255, 255, 0.5); text-align: center; margin-top: 0.5rem;">
          Searching Database
        </p>
      </div>
    )}
  </div>
</BaseLayout>

<style>
  /* Wood Floor Background Card - Always visible */
  .entity-card {
    background: url('/images/woodfloor/Moss_Woodsf_Laub.png');
    background-size: cover;
    background-position: center;
    border-radius: 20px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.12);
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex;
    flex-direction: column;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
    height: auto;
    position: relative;
  }
  
  /* Dark overlay for better readability */
  .entity-card::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.64));
    pointer-events: none;
    z-index: 1;
    transition: background 0.4s ease;
  }
  
  .entity-card > * {
    position: relative;
    z-index: 2;
  }

  .entity-card:hover,
  .entity-card.touch-hover {
    transform: translateY(-8px) scale(1.02);
    box-shadow: 0 16px 48px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.1) inset;
    border-color: rgba(255, 255, 255, 0.2);
  }
  
  .entity-card:hover::before,
  .entity-card.touch-hover::before {
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.9));
  }

  .card-image {
    width: 100%;
    height: 0;
    padding-bottom: 75%; /* 4:3 aspect ratio - more compact */
    overflow: hidden;
    background: rgba(0, 0, 0, 0.2);
    position: relative;
  }

  .card-image image-morph {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  /* Force contain fit for images in cards */
  .card-image image-morph::part(image),
  .card-image image-morph .image,
  .card-image image-morph img {
    object-fit: contain !important;
  }

  .image-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(to top, rgba(0, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0.7) 50%, transparent 100%);
    padding: 0.75rem; /* Reduced padding */
    display: flex;
    gap: 0.75rem; /* Reduced gap */
    align-items: flex-end;
    z-index: 10;
  }

  .taxonomy-badge {
    display: flex;
    flex-direction: column;
    gap: 0.0625rem; /* Minimal gap */
  }

  .taxonomy-label {
    font-size: 0.5625rem; /* Smaller label */
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: rgba(255, 255, 255, 0.6);
  }

  .taxonomy-value {
    font-size: 0.8125rem; /* Smaller value */
    font-weight: 600;
    color: white;
    font-style: italic;
  }

  .card-header {
    padding: 1.25rem; /* Reduced from 2rem */
    backdrop-filter: none;
    flex-shrink: 0;
  }

  .card-header name-morph {
    display: block;
  }

  .card-header name-morph:first-child {
    margin-bottom: 0.5rem; /* Reduced from 0.75rem */
    font-size: 1.25rem; /* Slightly smaller */
    line-height: 1.3;
  }

  .quick-info {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.625rem 1rem; /* Reduced gaps */
    margin-top: 0.75rem; /* Reduced from 1rem */
    padding-top: 0.75rem; /* Reduced from 1rem */
  }

  .info-item {
    display: flex;
    flex-direction: column;
    gap: 0.1875rem; /* Reduced from 0.25rem */
    font-size: 0.8125rem;
  }

  .info-label {
    color: rgba(255, 255, 255, 0.5);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    font-size: 0.625rem; /* Slightly smaller */
  }

  .info-value {
    color: rgba(255, 255, 255, 0.95);
    font-weight: 600;
    font-size: 0.8125rem; /* Slightly smaller */
  }

  .card-data {
    padding: 1.25rem;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    overflow-y: auto;
    overflow-x: hidden;
    max-height: 400px;
    scrollbar-width: none;
    -ms-overflow-style: none;
    width: 100%;
    box-sizing: border-box;
  }

  /* Hide scrollbar for Chrome/Safari/Opera */
  .card-data::-webkit-scrollbar {
    display: none;
  }

  /* Morph field wrapper with label */
  .card-data .morph-field {
    display: flex;
    flex-direction: column;
    gap: 0.375rem;
    margin-bottom: 0.5rem;
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
    overflow: hidden;
  }
  
  .card-data .morph-label {
    font-size: 0.6875rem;
    font-weight: 600;
    color: rgba(255, 255, 255, 0.5);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  
  /* Style all morph types in card-data */
  .card-data name-morph,
  .card-data text-morph,
  .card-data tag-morph,
  .card-data boolean-morph,
  .card-data number-morph,
  .card-data list-morph,
  .card-data data-morph,
  .card-data range-morph,
  .card-data key-value-morph {
    margin-bottom: 0;
    max-width: 100%;
    overflow: hidden;
    word-wrap: break-word;
    overflow-wrap: break-word;
  }
  
  /* Legacy data-morph support */
  .card-data data-morph {
    order: 999; /* Default: hidden at bottom until perspective activates */
  }

  .card-link {
    display: block;
    padding: 0.875rem 1.25rem; /* Reduced padding */
    text-align: center;
    background: rgba(0, 0, 0, 0.2);
    backdrop-filter: blur(8px);
    color: rgba(255, 255, 255, 0.9);
    text-decoration: none;
    font-weight: 600;
    font-size: 0.8125rem; /* Slightly smaller */
    text-transform: uppercase;
    letter-spacing: 0.05em;
    transition: all 0.3s ease;
    margin-top: auto;
    flex-shrink: 0;
  }

  .card-link:hover {
    background: rgba(0, 0, 0, 0.7);
    color: #22c55e;
    box-shadow: 0 -2px 12px rgba(34, 197, 94, 0.3) inset, 0 0 20px rgba(34, 197, 94, 0.1);
  }

  /* View Toggle - Black Glassmorphism */
  .view-toggle {
    display: flex;
    gap: 0.5rem;
    background: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(16px);
    padding: 0.375rem;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.02) inset;
  }

  .view-btn {
    padding: 0.75rem 1.5rem;
    background: transparent;
    border: none;
    border-radius: 8px;
    color: rgba(255, 255, 255, 0.6);
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .view-btn:hover {
    background: rgba(0, 0, 0, 0.6);
    color: rgba(255, 255, 255, 0.9);
  }

  .view-btn.active {
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(8px);
    color: white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1) inset;
  }

  /* Bubble Host */
  #bubble-view-host {
    margin-bottom: 2rem;
  }

  /* Entity Grid */
  .entity-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
    gap: 2.5rem;
    margin-bottom: 4rem;
    padding: 1rem 0;
    align-items: start; /* Align cards to top for better visual balance */
  }
  
  /* Morphs */
  .morphs {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }
  
  /* Tags */
  .tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin: 0.5rem 0;
  }
  
  /* Detail Link */
  .detail-link {
    display: inline-block;
    margin-top: 1rem;
    padding: 0.5rem 1rem;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    text-decoration: none;
    border-radius: 8px;
    font-weight: 500;
    transition: all 0.2s ease;
  }
  
  .detail-link:hover {
    transform: translateX(4px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
  }
  
  /* Empty State */
  .empty-state {
    grid-column: 1 / -1;
    padding: 4rem 2rem;
    text-align: center;
  }
  
  /* Responsive */
  @media (max-width: 768px) {
    .entity-grid {
      grid-template-columns: 1fr;
      gap: 1.5rem;
    }
    
    .entity-card {
      padding: 1rem;
    }

    header {
      flex-direction: column;
      align-items: flex-start !important;
    }
  }
  
  /* Dark Mode */
  @media (prefers-color-scheme: dark) {
    .entity-card {
      /* Keep wood floor background visible in dark mode */
      color: rgba(255, 255, 255, 0.9);
    }
  }
</style>

<script define:vars={{ entities }}>
  // Wait for AMORPH and hosts to load
  async function initViewToggle() {
    const amorph = window.amorph;
    if (!amorph) {
      console.log('‚è≥ Waiting for AMORPH...');
      setTimeout(initViewToggle, 100);
      return;
    }

    // Get host elements
    const bubbleHost = document.getElementById('bubble-view-host');
    const gridHost = document.getElementById('grid-view-host');
    
    if (!bubbleHost || !gridHost) {
      console.warn('‚ö†Ô∏è Host elements not found, retrying...');
      setTimeout(initViewToggle, 100);
      return;
    }

    // Wait for bubbleHost to be fully upgraded (web component ready)
    if (!bubbleHost.setData) {
      console.log('‚è≥ Waiting for BubbleHost to upgrade...');
      setTimeout(initViewToggle, 100);
      return;
    }

    // DATENGETRIEBEN: Pass entity data to BubbleHost
    console.log('üìä Entity data:', entities);
    bubbleHost.setData(entities);
    console.log(`‚úÖ Passed ${entities.length} entities to BubbleHost`);

    // Enable connections by default for similarity visualization
    setTimeout(() => {
      const bubbleView = bubbleHost.shadowRoot?.querySelector('bubble-view');
      if (bubbleView) {
        bubbleView.showConnections = true;
        console.log('‚úÖ Enabled similarity-based connections in BubbleView');
      }
    }, 1000);

    // REMOVED: AstroDataSearchReactor - Replaced by SearchFilterController (see line 787-792)
    // SearchFilterController provides better performance and cleaner implementation

    // MorphHeader will initialize with 4 default perspectives automatically
    console.log('‚úÖ Perspectives will be initialized by MorphHeader');

    // FIFO Perspective Ordering System
    const perspectiveOrder = [];
    const perspectiveFieldMap = {
      'safetyAndIdentification': ['edibility', 'toxicityLevel'],
      'ecologyAndHabitat': ['ecologyAndHabitat.seasonality.primarySeason', 'ecologyAndHabitat.substrate'],
      'physicalCharacteristics': ['physicalCharacteristics.capColor', 'physicalCharacteristics.sporePrintColor'],
      'culinaryAndNutritional': ['culinaryAndNutritional.flavorProfile', 'culinaryAndNutritional.preparationMethods'],
      'medicinalAndHealth': ['medicinalAndHealth.medicinalProperties', 'medicinalAndHealth.activeCompounds'],
      'cultivationAndProcessing': ['cultivationAndProcessing.cultivationDifficulty', 'cultivationAndProcessing.cultivationMethods'],
      'culturalAndHistorical': ['culturalAndHistorical.historicalSignificance', 'culturalAndHistorical.firstDocumented'],
      'commercialAndMarket': ['commercialAndMarket.commercialValue', 'commercialAndMarket.marketSegments', 'commercialAndMarket.commercialProducts'],
      'environmentalAndConservation': ['environmentalAndConservation.ecologicalRole', 'environmentalAndConservation.ecosystemServices'],
      'researchAndInnovation': ['researchAndInnovation.researchInterest', 'activeResearchAreas', 'innovativeApplications'],
      'chemicalAndProperties': ['primaryCompounds', 'secondaryMetabolites'],
      'taxonomy': ['kingdom', 'phylum', 'class', 'order']
    };

    function updateDataMorphOrder() {
      const cards = document.querySelectorAll('.card-data');
      
      cards.forEach((cardData) => {
        const morphs = Array.from(cardData.querySelectorAll('data-morph'));
        
        morphs.forEach(morph => {
          const field = morph.getAttribute('field');
          let order = 999;
          
          for (let i = 0; i < perspectiveOrder.length; i++) {
            const perspectiveName = perspectiveOrder[i];
            const fields = perspectiveFieldMap[perspectiveName] || [];
            if (fields.includes(field)) {
              order = i * 10;
              break;
            }
          }
          
          morph.style.order = order;
        });
      });
    }

    // Listen to perspective changes from MorphHeader
    // MorphHeader dispatches: window.dispatchEvent(new CustomEvent('perspective-changed', { detail: { perspectives } }))
    console.log('‚úÖ Setting up perspective-changed listener');
    
    const perspectiveHandler = (event) => {
      const perspectives = event.detail?.perspectives || [];
      if (perspectives.length === 0) return;
      
      // SIMPLE FIFO: MorphHeader adds new perspectives to the END
      // So we REVERSE the array to get newest first
      perspectiveOrder.length = 0;
      perspectiveOrder.push(...perspectives.slice().reverse());
      
      updateDataMorphOrder();
    };
    
    // Listen ONLY to window event (MorphHeader dispatches to both window and document)
    window.addEventListener('perspective-changed', perspectiveHandler);
    
    console.log('‚úÖ Perspective listeners registered');

    // View Toggle functionality with coordinated state
    const viewBtns = document.querySelectorAll('.view-btn');
    let currentView = 'grid'; // Track current view

    viewBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        const view = btn.dataset.view;
        if (view === currentView) return; // Already on this view
        
        currentView = view;
        
        // Update active state
        viewBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Toggle views and activate appropriate reactors
        if (view === 'grid') {
          // Show Grid, Hide Bubble
          bubbleHost.style.display = 'none';
          gridHost.style.display = 'grid'; // Must be 'grid' not 'block'
          
          // Force reflow to ensure cards are visible
          void gridHost.offsetHeight;
          
          // Grid View: SearchFilterController handles search (already initialized)
          // Perspectives and search state are already shared via events
          
          const searchQuery = amorph.state.searchQuery || 'none';
          const perspectiveCount = amorph.state?.activePerspectives?.length || 0;
          console.log(`[ViewToggle] üìä Grid View | Search: "${searchQuery}" | Perspectives: ${perspectiveCount} active`);
          
        } else {
          // Show Bubble, Hide Grid
          gridHost.style.display = 'none';
          bubbleHost.style.display = 'block';
          
          // Bubble View: Enable perspective weighting and connections
          const bubbleView = bubbleHost.shadowRoot?.querySelector('bubble-view');
          if (bubbleView) {
            // Ensure connections are visible for relationship view
            bubbleView.showConnections = true;
            
            // üé® Re-enable Canvas Reactors when switching to Bubble View
            if (!bubbleView.reactorsEnabled) {
              bubbleView.enableCanvasReactors();
            }
            
            // Trigger similarity recalculation with current perspectives
            bubbleView.updateSimilarityMatrix();
            
            const searchQuery = amorph.state.searchQuery || 'none';
            const perspectiveCount = amorph.state?.activePerspectives?.length || 0;
            console.log(`[ViewToggle] ü™∑ Bubble View | Search: "${searchQuery}" | Perspectives: ${perspectiveCount} active | Connections: enabled`);
          }
          
          // Enable BubbleView-specific reactors
          if (window.amorph) {
            window.amorph.enableReactor('bubbleDetail');
            window.amorph.enableReactor('bubbleSearch');
            console.log('[ViewToggle] ‚úÖ Bubble reactors enabled (BubbleDetail, BubbleSearch)');
            
            // Trigger perspective update on all bubble morphs
            const bubbles = bubbleHost.shadowRoot?.querySelectorAll('bubble-morph') || [];
            bubbles.forEach(bubble => {
              if (window.amorph.state?.activePerspectives) {
                bubble.activePerspectives = window.amorph.state.activePerspectives;
                bubble.requestUpdate();
              }
            });
            if (bubbles.length > 0) {
              console.log(`[ViewToggle] üîÑ Updated ${bubbles.length} bubbles with active perspectives`);
            }
            
            // If there's an active search with cached results, apply to Bubble View
            const searchQuery = window.amorph.state?.searchQuery;
            const cachedResults = window.amorph.state?.searchResults;
            if (searchQuery && searchQuery.trim() !== '' && cachedResults && cachedResults.length > 0) {
              console.log('üîç [ViewToggle] Applying cached search to Bubble View:', searchQuery, `(${cachedResults.length} results)`);
              window.dispatchEvent(new CustomEvent('convex-search:completed', {
                detail: {
                  query: searchQuery,
                  results: cachedResults
                }
              }));
            } else if (searchQuery && searchQuery.trim() !== '') {
              console.log('‚ö†Ô∏è [ViewToggle] Search query exists but no cached results - skipping bubble creation');
            }
          }
        }
        
        // Both views share:
        // ‚úì Search query (via amorph.state.searchQuery and search:input events)
        // ‚úì Perspectives (via MorphHeader perspective-changed events)
        // ‚úì User interactions persist across view switches
      });
    });

    console.log('‚úÖ View toggle initialized with', entities.length, 'entities');
    console.log('‚úÖ Shared state: Search + Perspectives coordinated across views');
  }

  // Start initialization
  console.log('üöÄ Starting view toggle initialization...');
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initViewToggle);
  } else {
    initViewToggle();
  }
</script>

<!-- Search Filter Controller (NEW) -->
<script type="module">
  import { SearchFilterController } from '/src/amorph/features/search-system/SearchFilterController.js';
  
  // Initialize search filter for Grid View
  const searchFilter = new SearchFilterController('.entity-grid', '.entity-card');
  
  console.log('üîç SearchFilterController initialized for Grid View');
</script>

<!-- Dynamic DataMorph Mode Switcher -->
<script type="module">
  /**
   * üîÑ DYNAMIC DATAMORPH MODE SWITCHER
   * ==================================
   * 
   * Switches data-morph display modes based on user interaction:
   * - Initial load: mode="simple" with relevant fields (10 fields max)
   * - After search: mode="deep" showing ALL matched data
   * - After perspective change: mode="deep" showing ALL perspective data
   * 
   * This gives users full context when searching/filtering while keeping
   * initial load clean and performant.
   */
  
  class DataMorphModeSwitcher {
    constructor() {
      this.isSearchActive = false;
      this.isPerspectiveActive = false;
      this.currentQuery = '';
      this.matchedFields = {};
      this.activePerspectives = [];
      
      this.init();
    }
    
    init() {
      // Wait for DOM
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => this.setup());
      } else {
        this.setup();
      }
    }
    
    setup() {
      console.log('[DataMorphModeSwitcher] üé¨ Initializing...');
      
      // Store original field values in dataset for restoration
      const dataMorphs = document.querySelectorAll('.card-data data-morph[field]');
      dataMorphs.forEach(morph => {
        const field = morph.getAttribute('field');
        if (field) {
          morph.dataset.originalField = field;
        }
      });
      
      // Listen for search events
      window.addEventListener('convex-search:completed', (event) => {
        this.handleSearchCompleted(event.detail);
      });
      
      window.addEventListener('convex-search:reset', () => {
        this.handleSearchReset();
      });
      
      // Listen for perspective changes
      if (typeof amorph !== 'undefined') {
        amorph.on('perspectives:changed', (data) => {
          this.handlePerspectiveChange(data);
        });
      }
      
      console.log('[DataMorphModeSwitcher] ‚úÖ Ready - Listening for search and perspective events');
    }
    
    /**
     * Handle search completed - switch to deep mode
     */
    handleSearchCompleted(searchData) {
      const { query, results, matchedFields } = searchData;
      
      const fieldCount = matchedFields ? Object.keys(matchedFields).length : 0;
      console.log(`[DataMorphModeSwitcher] üîç Search "${query}" ‚Üí ${results?.length || 0} results (${fieldCount} with matched fields)`);
      
      // Update state
      this.isSearchActive = !!(query && query.trim().length >= 2);
      this.currentQuery = query || '';
      this.matchedFields = matchedFields || {};
      
      if (this.isSearchActive) {
        this.switchToDeepMode('search');
      } else {
        this.switchToSimpleMode();
      }
    }
    
    /**
     * Handle search reset - switch back to simple mode
     */
    handleSearchReset() {
      console.log('[DataMorphModeSwitcher] üîÑ Search reset');
      
      this.isSearchActive = false;
      this.currentQuery = '';
      this.matchedFields = {};
      
      // Only switch back to simple if no perspective is active
      if (!this.isPerspectiveActive) {
        this.switchToSimpleMode();
      }
    }
    
    /**
     * Handle perspective change - switch to deep mode
     */
    handlePerspectiveChange(data) {
      const { perspectives } = data || {};
      
      const perspectiveStr = perspectives?.join(', ') || 'none';
      console.log(`[DataMorphModeSwitcher] üé≠ Perspectives: ${perspectiveStr}`);
      
      this.isPerspectiveActive = !!(perspectives && perspectives.length > 0);
      this.activePerspectives = perspectives || [];
      
      if (this.isPerspectiveActive) {
        this.switchToDeepMode('perspective');
      } else if (!this.isSearchActive) {
        // Only switch back to simple if search is also inactive
        this.switchToSimpleMode();
      }
    }
    
    /**
     * Switch all visible cards to deep mode
     */
    switchToDeepMode(reason = 'unknown') {
      // Get all visible cards (not hidden by search filter)
      const cards = document.querySelectorAll('.entity-card');
      let updatedCount = 0;
      
      cards.forEach(card => {
        // Skip hidden cards
        if (card.style.display === 'none') return;
        
        // Get all data-morphs in this card
        const dataMorphs = card.querySelectorAll('.card-data data-morph');
        
        dataMorphs.forEach((morph, index) => {
          if (index === 0) {
            // First morph: switch to deep mode (will render ALL perspectives)
            morph.setAttribute('mode', 'deep');
            morph.removeAttribute('field');
            morph.style.display = '';
            updatedCount++;
          } else {
            // Other morphs: hide them to prevent duplication
            morph.style.display = 'none';
          }
        });
      });
      
      console.log(`[DataMorphModeSwitcher] ‚úÖ Updated ${updatedCount} cards to deep mode (hidden duplicates)`);
    }
    
    /**
     * Switch all cards back to simple mode with relevant fields
     */
    switchToSimpleMode() {
      console.log('[DataMorphModeSwitcher] üìÑ Switching to SIMPLE mode (relevant fields)');
      
      // Get all cards
      const cards = document.querySelectorAll('.entity-card');
      let updatedCount = 0;
      
      cards.forEach(card => {
        // Get all data-morphs in this card
        const dataMorphs = card.querySelectorAll('.card-data data-morph');
        
        dataMorphs.forEach((morph, index) => {
          // Show all morphs again (they were hidden in deep mode)
          morph.style.display = '';
          
          // Remove deep mode
          if (morph.hasAttribute('mode')) {
            morph.removeAttribute('mode');
          }
          
          // Restore field attribute from original field (stored in dataset)
          const originalField = morph.dataset.originalField;
          if (originalField) {
            morph.setAttribute('field', originalField);
          }
          
          updatedCount++;
        });
      });
      
      console.log(`[DataMorphModeSwitcher] ‚úÖ Updated ${updatedCount} data-morphs to simple mode`);
    }
  }
  
  // Initialize
  new DataMorphModeSwitcher();
</script>

<!-- MorphMapper Client-Side Initialization -->
<script type="module">
  /**
   * üó∫Ô∏è MORPH MAPPER CLIENT INITIALIZATION
   * ======================================
   * 
   * Dynamically creates morph elements based on data attributes
   * using the MorphMapper to select the correct morph type
   */
  
  async function initMorphMapper() {
    // Wait for MorphMapper to be available
    await new Promise(resolve => {
      if (window.amorph?.morphMapper) {
        resolve();
      } else {
        const checkInterval = setInterval(() => {
          if (window.amorph?.morphMapper) {
            clearInterval(checkInterval);
            resolve();
          }
        }, 100);
      }
    });

    const mapper = window.amorph.morphMapper;
    console.log('[MorphMapper] ‚úÖ Client initialization starting...');

    // Find all card-data containers that need dynamic morphs
    const containers = document.querySelectorAll('.card-data[data-use-mapper="true"]');
    let totalMorphsCreated = 0;

    containers.forEach(container => {
      try {
        const entityDataStr = container.getAttribute('data-entity');
        if (!entityDataStr) return;

        const entityData = JSON.parse(entityDataStr);
        
        // Get mapped fields - NORMAL MODE: top 15 fields only
        // Search will expand to show ALL fields when active
        const fields = mapper.getMappedFields(entityData, {
          maxFields: 15,  // Limit in normal view
          maxDepth: 1
        });
        
        // Create and append morph elements
        fields.forEach(fieldConfig => {
          // Creating: ${fieldConfig.fieldName} ‚Üí ${fieldConfig.morphType}
          const morphElement = mapper.createMorphElement(fieldConfig, entityData);
          morphElement.setAttribute('data-priority', fieldConfig.priority);
          morphElement.setAttribute('data-morph-type', fieldConfig.morphType);
          morphElement.setAttribute('data-field-path', fieldConfig.fullPath);
          container.appendChild(morphElement);
          totalMorphsCreated++;
        });
        
        // Store full data for search expansion
        container.dataset.fullData = entityDataStr;
        
      } catch (error) {
        console.error('[MorphMapper] Error creating morphs:', error);
      }
    });

    console.log(`[MorphMapper] ‚úÖ Created ${totalMorphsCreated} morphs across ${containers.length} cards`);
    
    // Debounce for card expansion/collapse (prevent re-render on every keystroke)
    let expansionTimer = null;
    let collapseTimer = null;
    let isExpanded = false;
    
    // Listen for search events to expand cards
    window.addEventListener('convex-search:completed', (event) => {
      const { query } = event.detail;
      
      // Clear existing timers
      if (expansionTimer) {
        clearTimeout(expansionTimer);
      }
      if (collapseTimer) {
        clearTimeout(collapseTimer);
      }
      
      if (query && query.trim().length >= 2) {
        // Only expand if not already expanded (prevent redundant re-renders)
        if (!isExpanded) {
          expansionTimer = setTimeout(() => {
            expandCardsForSearch(containers, mapper);
            isExpanded = true;
          }, 500); // Wait 500ms after typing stops
        }
      } else if (isExpanded) {
        // Only collapse if currently expanded AND query is too short
        // Debounced to prevent freezing when deleting last characters
        collapseTimer = setTimeout(() => {
          collapseCardsToNormal(containers);
          isExpanded = false;
        }, 500);
      }
    });
    
    window.addEventListener('convex-search:reset', () => {
      if (expansionTimer) {
        clearTimeout(expansionTimer);
      }
      if (collapseTimer) {
        clearTimeout(collapseTimer);
      }
      
      // Only collapse if expanded
      if (isExpanded) {
        collapseTimer = setTimeout(() => {
          collapseCardsToNormal(containers);
          isExpanded = false;
        }, 300);
      }
    });
  }
  
  // Expand cards to show ALL fields during search
  function expandCardsForSearch(containers, mapper) {
    console.log('[MorphMapper] üîç Expanding cards to show ALL fields for search...');
    
    containers.forEach(container => {
      const entityDataStr = container.dataset.fullData;
      if (!entityDataStr) return;
      
      const entityData = JSON.parse(entityDataStr);
      
      // Get ALL fields (no limit)
      const allFields = mapper.getMappedFields(entityData, {
        maxFields: null,  // Show everything during search
        maxDepth: 2       // Include nested data
      });
      
      // Remove existing morphs
      container.innerHTML = '';
      
      // Create morphs for ALL fields
      allFields.forEach(fieldConfig => {
        const morphElement = mapper.createMorphElement(fieldConfig, entityData);
        morphElement.setAttribute('data-priority', fieldConfig.priority);
        morphElement.setAttribute('data-morph-type', fieldConfig.morphType);
        morphElement.setAttribute('data-field-path', fieldConfig.fullPath);
        morphElement.classList.add('search-expanded');
        container.appendChild(morphElement);
      });
    });
  }
  
  // Collapse cards back to top 15 fields
  function collapseCardsToNormal(containers) {
    console.log('[MorphMapper] üìÑ Collapsing cards to normal view (top 15 fields)...');
    
    const mapper = window.amorph.morphMapper;
    
    containers.forEach(container => {
      // Skip if already collapsed (check for search-expanded class)
      const hasExpandedMorphs = container.querySelector('.search-expanded');
      if (!hasExpandedMorphs) {
        console.log('[MorphMapper] ‚è≠Ô∏è Already collapsed, skipping');
        return;
      }
      
      const entityDataStr = container.dataset.fullData;
      if (!entityDataStr) return;
      
      const entityData = JSON.parse(entityDataStr);
      
      // Get top 15 fields only
      const topFields = mapper.getMappedFields(entityData, {
        maxFields: 15,
        maxDepth: 1
      });
      
      // Use requestAnimationFrame to prevent blocking UI
      requestAnimationFrame(() => {
        // Remove existing morphs
        container.innerHTML = '';
        
        // Create morphs for top fields only
        topFields.forEach(fieldConfig => {
          const morphElement = mapper.createMorphElement(fieldConfig, entityData);
          morphElement.setAttribute('data-priority', fieldConfig.priority);
          morphElement.setAttribute('data-morph-type', fieldConfig.morphType);
          morphElement.setAttribute('data-field-path', fieldConfig.fullPath);
          container.appendChild(morphElement);
        });
        
        console.log('[MorphMapper] ‚úÖ Collapsed to top 15 fields');
      });
    });
  }

  // Start initialization
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initMorphMapper);
  } else {
    initMorphMapper();
  }
</script>

<!-- Touch Hover Effects -->
<script type="module">
  // Touch-friendly hover effects for mobile scrolling
  function initTouchHover() {
    const cards = document.querySelectorAll('.entity-card');
    let lastTouchedCard = null;
    
    cards.forEach(card => {
      // Touch start - add hover class
      card.addEventListener('touchstart', (e) => {
        // Remove hover from previously touched card
        if (lastTouchedCard && lastTouchedCard !== card) {
          lastTouchedCard.classList.remove('touch-hover');
        }
        
        // Add hover to current card
        card.classList.add('touch-hover');
        lastTouchedCard = card;
      }, { passive: true });
      
      // Touch end - keep hover until next card is touched
      card.addEventListener('touchend', () => {
        // Don't remove hover - it stays until another card is touched
      }, { passive: true });
    });
  }
  
  // Initialize after DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTouchHover);
  } else {
    initTouchHover();
  }
  
  console.log('üëÜ Touch-friendly hover initialized');
</script>
